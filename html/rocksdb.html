<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>rocksdb</title>


<style type="text/css">
*{margin:0;padding:0;}
body {
	font:13.34px helvetica,arial,freesans,clean,sans-serif;
	color:black;
	line-height:1.4em;
	background-color: #F8F8F8;
	padding: 0.7em;
}
p {
	margin:1em 0;
	line-height:1.5em;
}
table {
	font-size:inherit;
	font:100%;
	margin:1em;
}
table th{border-bottom:1px solid #bbb;padding:.2em 1em;}
table td{border-bottom:1px solid #ddd;padding:.2em 1em;}
input[type=text],input[type=password],input[type=image],textarea{font:99% helvetica,arial,freesans,sans-serif;}
select,option{padding:0 .25em;}
optgroup{margin-top:.5em;}
pre,code{font:12px Monaco,"Courier New","DejaVu Sans Mono","Bitstream Vera Sans Mono",monospace;}
pre {
	margin:1em 0;
	font-size:12px;
	background-color:#eee;
	border:1px solid #ddd;
	padding:5px;
	line-height:1.5em;
	color:#444;
	overflow:auto;
	-webkit-box-shadow:rgba(0,0,0,0.07) 0 1px 2px inset;
	-webkit-border-radius:3px;
	-moz-border-radius:3px;border-radius:3px;
}
pre code {
	padding:0;
	font-size:12px;
	background-color:#eee;
	border:none;
}
code {
	font-size:12px;
	background-color:#f8f8ff;
	color:#444;
	padding:0 .2em;
	border:1px solid #dedede;
}
img{border:0;max-width:100%;}
abbr{border-bottom:none;}
a{color:#4183c4;text-decoration:none;}
a:hover{text-decoration:underline;}
a code,a:link code,a:visited code{color:#4183c4;}
h2,h3{margin:1em 0;}
h1,h2,h3,h4,h5,h6{border:0;}
h1{font-size:170%;border-top:4px solid #aaa;padding-top:.5em;margin-top:1.5em;}
h1:first-child{margin-top:0;padding-top:.25em;border-top:none;}
h2{font-size:150%;margin-top:1.5em;border-top:4px solid #e0e0e0;padding-top:.5em;}
h3{margin-top:1em;}
hr{border:1px solid #ddd;}
ul{margin:1em 0 1em 2em;}
ol{margin:1em 0 1em 2em;}
ul li,ol li{margin-top:.5em;margin-bottom:.5em;}
ul ul,ul ol,ol ol,ol ul{margin-top:0;margin-bottom:0;}
blockquote{margin:1em 0;border-left:5px solid #ddd;padding-left:.6em;color:#555;}
dt{font-weight:bold;margin-left:1em;}
dd{margin-left:2em;margin-bottom:1em;}
sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
kbd {
  display: inline-block;padding: 3px 5px;font-size: 11px;line-height: 10px;color: #555;vertical-align: middle;background-color: #fcfcfc;border: solid 1px #ccc;border-bottom-color: #bbb;border-radius: 3px;box-shadow: inset 0 -1px 0 #bbb;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>


</head>

<body>

<h2 id="toc_0">RocksDB 笔记</h2>

<hr>

<p><em>written by Alex Stocks on 2018/03/28，版权所有，无授权不得转载</em></p>

<h3 id="toc_1">0 说明</h3>

<hr>

<p>近日在写一个分布式 KV DB，存储层使用了 RocksDB。</p>

<p>RocksDB 的优点此处无需多说，它的 feature 是其有很多优化选项用于对 RocksDB 进行调优。欲熟悉这些参数，必须对其背后的原理有所了解，本文主要整理一些 RocksDB 的 wiki 文档，以备自己参考之用。</p>

<h3 id="toc_2">1 <a href="https://github.com/facebook/rocksdb/wiki/Block-Cache">Block Cache</a></h3>

<hr>

<p>Block Cache是RocksDB的数据的缓存，这个缓存可以在多个RocksDB的实例下缓存。一般默认的Block Cache中存储的值是未压缩的，而用户可以再指定一个Block Cache，里面的数据可以是压缩的。用户访问数据先访问默认的BC，待无法保证后再访问用户Cache，用户Cache的数据可以直接存入page cache中。</p>

<p>Cache 有两种：LRUCache 和 BlockCache。Block 分为很多 Shard，以减小竞争，所以 shard 大小均匀一致相等，默认 Cache 有 64 个 shards，每个 shard 大小不超过 512k，总大小是 8M，类别是 LRU。</p>

<!---C++--->

<div><pre><code class="language-none">std::shared_ptr&lt;Cache&gt; cache = NewLRUCache(capacity);
BlockedBasedTableOptions table_options;
table_options.block_cache = cache;
Options options;
options.table_factory.reset(new BlockedBasedTableFactory(table_options));</code></pre></div>

<p>这个 Cache 是不压缩数据的，用户可以设置压缩数据 BlockCache，方法如下：</p>

<!---C++--->

<div><pre><code class="language-none">table_options.block_cache_compressed = cache;</code></pre></div>

<p>如果 Cache 为 nullptr，则RocksDB会创建一个，如果想禁用 Cache，可以设置如下 Option：</p>

<!---C++--->

<div><pre><code class="language-none">table_options.no_block_cache = true;</code></pre></div>

<p>默认情况下RocksDB用的是 LRUCache，大小是 8MB， 每个 shard 单独维护自己的 LRU list 和独立的
，以及自己的 Mutex。</p>

<p>RocksDB还提高了一个 ClockCache，每个 shard 有自己的一个 circular list，有一个 clock handle 会轮询这个 circular list，寻找过时的 kv，如果 entry 中的 kv 已经被访问过则可以继续存留，相对于 LRU 好处是无 mutex lock，circular list 本质是 tbb::concurrent<em>hash</em>map，从 benchmark 来看，二者命中率相似，但吞吐率 Clock 比 LRU 稍高。</p>

<p>Block Cache初始化之时相关参数：</p>

<ul>
<li>capacity 总的内存使用量</li>
<li>num_shards_bits 把 key 的前 n bits 作为 shard id，则总 shard 的数目为 2 ^ num_shards_bits；</li>
<li>strict_capacity_limit 在一些极端情况下 block cache 的总体使用量可能超过 capacity，如在对 block 进行读或者迭代读取的时候可能有插入数据的操作，此时可能因为加锁导致有些数据无法及时淘汰，使得总体capacity超标。如果这个选项设置为 true，则此时插入操作是被允许的，但有可能导致进程 OOM。如果设置为 false，则插入操作会被 refuse，同时读取以及遍历操作有可能失败。这个选项对每个 shard 都有效，这就意味着有的 shard 可能内存已满， 别的 shard 却有很多空闲。</li>
<li>high_pri_pool_ratio block中为高优先级的 block 保留多少比例的空间，这个选项只有 LRU Cache 有。</li>
</ul>

<p>默认情况下 index 和filter block 与 block cache 是独立的，用户不能设定二者的内存空间使用量，但为了控制 RocksDB 的内存空间使用量，可以用如下代码把 index 和 filter 也放在 block cache 中：</p>

<!---C++--->

<div><pre><code class="language-none">BlockBasedTableOptions table_options;
table_options.cache_index_and_filter_blocks = true;</code></pre></div>

<p>index 与 filter 一般访问频次比 data 高，所以把他们放到一起会导致内存空间与 cpu 资源竞争，进而导致 cache 性能抖动厉害。有如下两个参数需要注意：cache<em>index</em>filter<em>blocks</em>with<em>high</em>priority 和 high<em>pri</em>pool<em>ratio 一样，这个参数只对 LRU Cache 有效，两者须同时生效。这个选项会把 LRU Cache 划分为高 prio 和低 prio 区，data 放在 low 区，index 和 filter 放在 high 区，如果高区占用的内存空间超过了 capacity * high</em>pri<em>pool</em>ratio，则会侵占 low 区的尾部数据空间。</p>

<ul>
<li>pin_l0_filter_and_index_blocks_in_cache 把 level0 的 index 以及 filter block 放到 Block Cache 中，因为 l0 访问频次最高，一般内存容量不大，占用不了多大内存空间。</li>
</ul>

<p>SimCache 用于评测 Cache 的命中率，它封装了一个真正的 Cache，然后用给定的 capacity 进行 LRU 测算，代码如下:</p>

<!---C++--->

<div><pre><code class="language-none">// This cache is the actual cache use by the DB.
std::shared_ptr&lt;Cache&gt; cache = NewLRUCache(capacity);
// This is the simulated cache.
std::shared_ptr&lt;Cache&gt; sim_cache = NewSimCache(cache, sim_capacity, sim_num_shard_bits);
BlockBasedTableOptions table_options;
table_options.block_cache = sim_cache;</code></pre></div>

<p>大概只有容量的 2% 会被用于测算。</p>

<h3 id="toc_3">2 <a href="https://github.com/facebook/rocksdb/wiki/Memory-usage-in-RocksDB">RocksDB Memory</a></h3>

<hr>

<p>RocksDB的内存大致有如下四个区：</p>

<ul>
<li>Block Cache</li>
<li>Indexes and bloom filters</li>
<li>Memtables</li>
<li>Blocked pinned by iterators</li>
</ul>

<h4 id="toc_4">2.1 Block Cache</h4>

<hr>

<p>Block Cache 存储一些缓存数据，它的下一层是操作系统的 Page Cache。</p>

<h4 id="toc_5">2.2 Indexes and bloom filters</h4>

<hr>

<p>Index 由 key、offset 和 size 三部分构成，当 Block Cache 增大 Block Size 时，block 个数必会减小，index 个数也会随之降低，如果减小 key size，index 占用内存空间的量也会随之降低。</p>

<p>filter是 bloom filter 的实现，如果假阳率是 1%，每个key占用 10 bits，则总占用空间就是 <code>num_of_keys * 10 bits</code>，如果缩小 bloom 占用的空间，可以设置 <code>options.optimize_filters_for_hits = true</code>，则最后一个 level 的 filter 会被关闭，bloom 占用率只会用到原来的 10% 。</p>

<p>结合 block cache 所述，index &amp; filter 有如下优化选项：</p>

<ul>
<li><code>cache_index_and_filter_blocks</code> 这个 option 如果为 true，则 index &amp; filter 会被存入 block cache，而 block cache 中的内容会随着 page cache 被交换到磁盘上，这就会大大降低 RocksDB的性能，把这个 option 设为 true 的同时也把 <code>pin_l0_filter_and_index_blocks_in_cache</code> 设为 true，以减小对性能的影响。</li>
</ul>

<p>如果 <code>cache_index_and_filter_blocks</code> 被设置为 false （其值默认就是 false），index/filter 个数就会受 <code>max_open_files</code> 影响，官方建议把这个选项设置为 -1，以方便 RocksDB 加载所有的 index 和 filter 文件，最大化程序性能。</p>

<p>可以通过如下代码获取 index &amp; filter 内存量大小：</p>

<!---C++--->

<div><pre><code class="language-none">std::string out;
db-&gt;GetProperty(“rocksdb.estimate-table-readers-mem”, &amp;out);</code></pre></div>

<h4 id="toc_6">2.3 Indexes and bloom filters</h4>

<hr>

<p>block cache、index &amp; filter 都是读 buffer，而 memtable 则是写 buffer，所有 kv 首先都会被写进 memtable，其 size 是 <code>write_buffer_size</code>。 memtable 占用的空间越大，则写放大效应越小，因为数据在内存被整理好，磁盘上就越少的内容会被 compaction。如果 memtable 磁盘空间增大，则 L1 size 也就随之增大，L1 空间大小受 <code>max_bytes_for_level_base</code> option 控制。</p>

<p>可以通过如下代码获取 memtable 内存量大小：</p>

<!---C++--->

<div><pre><code class="language-none">std::string out;
db-&gt;GetProperty(“rocksdb.cur-size-all-mem-tables”, &amp;out);</code></pre></div>

<h4 id="toc_7">2.4 Blocks pinned by iterators</h4>

<hr>

<p>这部分内存空间一般占用总量不多，但是如果有 100k 之多的transactions 发生，每个 iterator 与一个 data block 外加一个 L1 的 data block，所以内存使用量大约为 <code>num_iterators * block_size * ((num_levels-1) + num_l0_files)</code>。</p>

<p>可以通过如下代码获取 Pin Blocks 内存量大小：</p>

<!---C++--->

<div><pre><code class="language-none">table_options.block_cache-&gt;GetPinnedUsage();</code></pre></div>

<h3 id="toc_8">3 <a href="https://github.com/facebook/rocksdb/wiki/Column-Families">Column Families</a></h3>

<hr>

<p>RocksDB 3.0 以后添加了一个 Column Family【后面简称 CF】 的feature，每个 kv 存储之时都必须指定其所在的 CF。RocksDB为了兼容以往版本，默认创建一个 “default” 的CF。存储 kv 时如果不指定 CF，RocksDB 会把其存入 “default” CF 中。</p>

<h3 id="toc_9">3.1 Option</h3>

<hr>

<p>RocksDB 的 Option 有 Options, ColumnFamilyOptions, DBOptions 三种。</p>

<p>ColumnFamilyOptions 是 table 级的，而 Options 是 DB 级的，Options 继承自 ColumnFamilyOptions 和 DBOptions，它一般影响只有一个 CF 的 DB，如 “default”。</p>

<p>每个 CF 都有一个 Handle：ColumnFamilyHandle，在 DB 指针被 delete 前，应该先 delete ColumnFamilyHandle。如果 ColumnFamilyHandle 指向的 CF 被别的使用者通过 DropColumnFamily 删除掉，这个 CF 仍然可以被访问，因为其引用计数不为 0.</p>

<p>在以 Read/Write 方式打开一个 DB 的时候，需要指定一个由所有将要用到的 CF string name 构成的 ColumnFamilyDescriptor array。不管 “default” CF 使用与否，都必须被带上。</p>

<p>CF 存在的意义是所有 table 共享 WAL，但不共享 memtable 和 table 文件，通过 WAL 保证原子写，通过分离 table 可快读快写快删除。每次 flush 一个 CF 后，都会新建一个 WAL，都这并不意味着旧的 WAL 会被删除，因为别的 CF 数据可能还没有落盘，只有所有的 CF 数据都被 flush 且所有的 WAL 有关的 data 都落盘，相关的 WAL 才会被删除。RocksDB 会定时执行 CF flush 任务，可以通过 <code>Options::max_total_wal_size</code> 查看已有多少旧的 CF 文件已经被 flush 了。</p>

<p>RocksDB 会在磁盘上依据 LSM 算法对多级磁盘文件进行 compaction，这会影响写性能，拖慢程序性能，可以通过 <code>WriteOptions.low_pri = true</code> 降低 compaction 的优先级。</p>

<h3 id="toc_10">3.2 <a href="https://github.com/facebook/rocksdb/wiki/Set-Up-Options">Set Up Option</a></h3>

<hr>

<p>RocksDB 有很多选项以为专门的目的进行以后，但是大部分情况下不需要进行特殊的优化。这里只列出一个常用的优化选项。</p>

<ul>
<li><code>cf_options.write_buffer_size</code></li>
</ul>

<p>CF 的 write buffer 的最大 size。最差情况下 RocksDB 使用的内存量会翻倍，所以一般情况下不要轻易修改其值。</p>

<ul>
<li>Set block cache size</li>
</ul>

<p>这个值一般设置为 RocksDB 想要使用的内存总量的 1/3，其余的留给 OS 的 page cache。</p>

<!---C++--->

<div><pre><code class="language-none">BlockBasedTableOptions table_options;
… \\ set options in table_options
options.table_factory.reset(new

std::shared_ptr&lt;Cache&gt; cache = NewLRUCache(&lt;your_cache_size&gt;);
table_options.block_cache = cache;

BlockBasedTableFactory(table_options));</code></pre></div>

<p>本进程的所有的 DB 所有的 CF 所有的 table<em>options 都必须使用同一个 cahce 对象，或者让所有的 DB 所有的 CF 使用同一个 table</em>options。</p>

<ul>
<li><code>cf_options.compression, cf_options.bottonmost_compression</code></li>
</ul>

<p>选择压缩方法跟你的机器、CPU 能力以及内存磁盘空间大小有关，官方推荐 <code>cf_options.compression</code> 使用 kLZ4Compression，<code>cf_options.bottonmost_compression</code> 使用 kZSTD，选用的时候要确认你的机器有这两个库，这两个选项也可以分别使用 Snappy 和 Zlib。</p>

<ul>
<li>Bloom filter</li>
</ul>

<p><font color=red><strong>官方真正建议修改的参数只有这个 filter 参数。如果大量使用迭代方法，不要修改这个参数，如果大量调用 Get() 接口，建议修改这个参数。</strong></font>修改方法如下：</p>

<!---C++--->

<div><pre><code class="language-none">table_options.filter_policy.reset(NewBloomFilterPolicy(10, false));</code></pre></div>

<p>一个可能的优化设定如下：</p>

<!---C++--->

<div><pre><code class="language-none">cf_options.level_compaction_dynamic_level_bytes = true;
options.max_background_compactions = 4;
options.max_background_flushes = 2;
options.bytes_per_sync = 1048576;
table_options.block_size = 16 * 1024;
table_options.cache_index_and_filter_blocks = true;
table_options.pin_l0_filter_and_index_blocks_in_cache = true;</code></pre></div>

<p>上面只是罗列了一些优化选项，这些选项也只能在进程启动的时候设定。更多的选项请详细阅读参考文档1。</p>

<h3 id="toc_11">4 <a href="https://github.com/facebook/rocksdb/wiki/RocksDB-Bloom-Filter">Bloom Filter</a></h3>

<hr>

<p>RocksDB 的每个 SST 文件都包含一个 Bloom filter。Bloom Filter 只对特定的一组 keys 有效，所以只有心的 SST 文件创建的时候才会生成这个 filter。当两个 SST 文件合并的时候，会生成新的 filter 数据。</p>

<p>当 SST 文件加载进内存的时候，filter 也会被加载进内存，当关闭 SST 文件的时候，filter 也会被关闭。如果想让 filter 常驻内存，可以用如下代码设置：</p>

<!---C++--->

<div><pre><code class="language-none">BlockBasedTableOptions::cache_index_and_filter_blocks=true</code></pre></div>

<p>一般情况下不要修改 filter 相关参数。如果需要修改，相关设置上面已经说过，此处不再多谈。</p>

<h3 id="toc_12">5 <a href="https://github.com/facebook/rocksdb/wiki/Basic-Operations">Basic Operations</a></h3>

<hr>

<p>上面说了很多优化相关的操作，下面介绍下一些基本操作。</p>

<p>一个进程对一个 DB 同时只能创建一个 rocksdb::DB 对象，所有线程共享之。这个对象内部有锁机制保证访问安全，多个线程同时进行 Get/Put/Fetch Iteration 都没有问题，但是如果直接 Iteration 或者 WriteBatch 则需要额外的锁同步机制保护 Iterator 或者 WriteBatch 对象。</p>

<h3 id="toc_13">5.1 WriteBatch</h3>

<hr>

<p>单独的 Get/Put/Delete 是原子操作，要么成功要么失败，不存在中间状态。</p>

<p>如果需要进行批量的 Get/Put/Delete 操作且需要操作保持原子属性，则可以使用 WriteBatch。</p>

<p>WriteBatch 还有一个好处是保持加快吞吐率。</p>

<h3 id="toc_14">5.2 同步写 与 异步写</h3>

<hr>

<p>默认情况下，RocksDB 的写是异步的：仅仅把数据写进了操作系统的缓存区就返回了，而这些数据被写进磁盘是一个异步的过程。如果为了数据安全，可以用如下代码把写过程改为同步写：</p>

<!---C++--->

<div><pre><code class="language-none">rocksdb::WriteOptions write_options;
write_options.sync = true;
db-&gt;Put(write_options, …);</code></pre></div>

<p>这个选项会启用 Posix 系统的 <code>fsync(...) or fdatasync(...) or msync(..., MS_SYNC)</code> 等函数。</p>

<p>异步写的吞吐率是同步写的一千多倍。异步写的缺点是机器或者操作系统崩溃时可能丢掉最近一批写请求发出的由操作系统缓存的数据，但是 RocksDB 自身崩溃并不会导致数据丢失。而机器或者操作系统崩溃的概率比较低，所以大部分情况下可以认为异步写是安全的。</p>

<p>RocksDB 由于有 WAL 机制保证，所以即使崩溃，其重启后会进行写重放保证数据一致性。如果不在乎数据安全性，可以把 <code>write_option.disableWAL</code> 设置为 true，加快写吞吐率。</p>

<p>RocksDB 调用 Posix API <code>fdatasync()</code> 对数据进行异步写。如果想用 <code>fsync()</code> 进行同步写，可以设置 <code>Options::use_fsync</code> 为 true。</p>

<h3 id="toc_15">5.3 Snapshots</h3>

<hr>

<p>RocksDB 能够保存某个版本的所有数据（可称之为一个 Snapshot）以方便读取操作，创建并读取 Snapshot 方法如下：</p>

<!---C++--->

<div><pre><code class="language-none">rocksdb::ReadOptions options;
options.snapshot = db-&gt;GetSnapshot();
… apply some updates to db …
rocksdb::Iterator* iter = db-&gt;NewIterator(options);
… read using iter to view the state when the snapshot was created …
delete iter;
db-&gt;ReleaseSnapshot(options.snapshot);</code></pre></div>

<p>如果 ReadOptions::snapshot 为 null，则读取的 snapshot 为 RocksDB 当前版本数据的 snapshot。</p>

<h3 id="toc_16">5.4 Slice</h3>

<hr>

<p>不管是 <code>it-&gt;key()</code> 还是 <code>it-&gt;value()</code>，其值类型都是 <code>rocksdb::Slice</code>。 Slice 自身由一个长度字段以及一个指向外部一个内存区域的指针构成，返回 Slice 比返回一个 string 廉价，并不存在内存拷贝的问题。RocksDB 自身会给 key 和 value 添加一个 C-style 的 ‘\0’，所以 slice 的指针指向的内存区域自身作为字符串输出没有问题。</p>

<p>Slice 与 string 之间的转换代码如下：</p>

<!---C++--->

<div><pre><code class="language-none">rocksdb::Slice s1 = “hello”;

std::string str(“world”);
rocksdb::Slice s2 = str;

OR:

std::string str = s1.ToString();
assert(str == std::string(“hello”));</code></pre></div>

<p>但是请注意 Slice 的安全性，有代码如下：</p>

<!---C++--->

<div><pre><code class="language-none">rocksdb::Slice slice;
if (…) {
 std::string str = …;
 slice = str;
}
Use(slice);</code></pre></div>

<p>当退出 if 语句块后，slice 内部指针指向的内存区域已经不存在，此时再使用导致程序出问题。</p>

<h3 id="toc_17">5.5 Transactions</h3>

<hr>

<h3 id="toc_18">5.6 Column Family</h3>

<hr>

<p>CF 提供了对 DB 进行逻辑划分开来的方法，用户可以通过 CF 同时对多个 CF 的 KV 进行并行读写的方法，提高了并行度。</p>

<h2 id="toc_19">参考文档</h2>

<hr>

<ul>
<li>1 <a href="https://github.com/facebook/rocksdb/wiki/RocksDB-Tuning-Guide">RocksDB Tuning Guide</a></li>
</ul>

<h2 id="toc_20">扒粪者-于雨氏</h2>

<blockquote>
<p>2018/01/09，于雨氏，初作此文于海淀。</p>
</blockquote>


<!-- baidu statistic start -->
<script>
var _hmt = _hmt || [];
(function() {
	  var hm = document.createElement("script");
	    hm.src = "https://hm.baidu.com/hm.js?170a8df8802fbc47c7acc272d270979c";
		  var s = document.getElementsByTagName("script")[0];
		    s.parentNode.insertBefore(hm, s);
})();
</script>
<!-- baidu statistic end -->

<!-- Gitalk start -->
<link rel="stylesheet" href="https://unpkg.com/gitalk@latest/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
var gitalk = new Gitalk({
	clientID: '6211d8b94a8106bed6b0',
	clientSecret: 'bf77ca26c237eabbd45169e01bf03a5e96a1b26f',
	repo: 'alexstocks.github.io',
	owner: 'AlexStocks',
	admin: ['AlexStocks'],
	id: window.location.pathname,
	distractionFreeMode: true
});
gitalk.render('gitalk-container');
</script>
<!-- Gitalk end -->




</body>

</html>
