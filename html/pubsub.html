<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>pubsub</title>


<style type="text/css">
*{margin:0;padding:0;}
body {
	font:13.34px helvetica,arial,freesans,clean,sans-serif;
	color:black;
	line-height:1.4em;
	background-color: #F8F8F8;
	padding: 0.7em;
}
p {
	margin:1em 0;
	line-height:1.5em;
}
table {
	font-size:inherit;
	font:100%;
	margin:1em;
}
table th{border-bottom:1px solid #bbb;padding:.2em 1em;}
table td{border-bottom:1px solid #ddd;padding:.2em 1em;}
input[type=text],input[type=password],input[type=image],textarea{font:99% helvetica,arial,freesans,sans-serif;}
select,option{padding:0 .25em;}
optgroup{margin-top:.5em;}
pre,code{font:12px Monaco,"Courier New","DejaVu Sans Mono","Bitstream Vera Sans Mono",monospace;}
pre {
	margin:1em 0;
	font-size:12px;
	background-color:#eee;
	border:1px solid #ddd;
	padding:5px;
	line-height:1.5em;
	color:#444;
	overflow:auto;
	-webkit-box-shadow:rgba(0,0,0,0.07) 0 1px 2px inset;
	-webkit-border-radius:3px;
	-moz-border-radius:3px;border-radius:3px;
}
pre code {
	padding:0;
	font-size:12px;
	background-color:#eee;
	border:none;
}
code {
	font-size:12px;
	background-color:#f8f8ff;
	color:#444;
	padding:0 .2em;
	border:1px solid #dedede;
}
img{border:0;max-width:100%;}
abbr{border-bottom:none;}
a{color:#4183c4;text-decoration:none;}
a:hover{text-decoration:underline;}
a code,a:link code,a:visited code{color:#4183c4;}
h2,h3{margin:1em 0;}
h1,h2,h3,h4,h5,h6{border:0;}
h1{font-size:170%;border-top:4px solid #aaa;padding-top:.5em;margin-top:1.5em;}
h1:first-child{margin-top:0;padding-top:.25em;border-top:none;}
h2{font-size:150%;margin-top:1.5em;border-top:4px solid #e0e0e0;padding-top:.5em;}
h3{margin-top:1em;}
hr{border:1px solid #ddd;}
ul{margin:1em 0 1em 2em;}
ol{margin:1em 0 1em 2em;}
ul li,ol li{margin-top:.5em;margin-bottom:.5em;}
ul ul,ul ol,ol ol,ol ul{margin-top:0;margin-bottom:0;}
blockquote{margin:1em 0;border-left:5px solid #ddd;padding-left:.6em;color:#555;}
dt{font-weight:bold;margin-left:1em;}
dd{margin-left:2em;margin-bottom:1em;}
sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
kbd {
  display: inline-block;padding: 3px 5px;font-size: 11px;line-height: 10px;color: #555;vertical-align: middle;background-color: #fcfcfc;border: solid 1px #ccc;border-bottom-color: #bbb;border-radius: 3px;box-shadow: inset 0 -1px 0 #bbb;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>


</head>

<body>

<h2 id="toc_0">一套高可用的pub/sub系统实现</h2>

<hr>

<p><em>written by Alex Stocks on 2017/12/31</em></p>

<h3 id="toc_1">1 极简实现</h3>

<hr>

<p>所谓系统pub/sub，就是一种群聊方式，譬如直播房间内的聊天对应的服务器端就是一个pub/sub系统。</p>

<p>2017年9月初初步实现了一套极简的pub/sub系统，其大致架构如下：</p>

<p><img src="../pic/pubsub_simple.png" alt=""></p>

<p>系统名词解释：</p>

<blockquote>
<p>1 Client : 系统消息发布者，publisher；</p>

<p>2 Proxy  : 系统代理，对外统一接口，收集Client发来的消息转发给Broker；</p>

<p>3 Broker ：系统Server，Broker会根据Gateway message组织Room ID和Gateway IP&amp;port的映射关系，然后把Proxy发来的消息转发到Room中所有成员登录的所有Gateway，；</p>

<p>4 Router ：用户登录消息转发者，把Gateway转发来的用户登入登出消息转发给所有的Broker；</p>

<p>5 Gateway：所有服务端的入口，接收合法客户端的连接，并把客户端的登录登出消息通过Router转发给所有的Broker；</p>

<p>当一个Room中多个Client连接一个Gateway的时候，Broker只会根据Room ID把房间内的消息转发一次给这个Gateway，由Gateway再把消息复制多份分别发送给连接这个Gateway的Room中的所有客户端。 </p>
</blockquote>

<p>这套系统有如下特点：   </p>

<ul>
<li>1 系统只转发房间内的聊天消息，每个节点收到后立即转发出去，不存储任何房间内的聊天消息，不考虑消息丢失以及消息重复的问题；</li>
<li>2 系统固定地由一个Proxy、三个Broker和一个Router构成；</li>
<li>3 Proxy接收后端发送来的房间消息，然后按照一定的负载均衡算法把消息发往某个Broker，Broker则把消息发送到所有与Room有关系的接口机Gateway；</li>
<li>4 Router接收Gateway转发来的某个Room内某成员在这个Gateway的登出或者登录消息，然后把消息发送到所有Broker；</li>
<li>5 Broker收到Router转发来的Gateway消息后，更新（添加或者删除）与某Room相关的Gateway集合记录；</li>
<li>6 整个系统的通信链路采用UDP通信方式；</li>
</ul>

<p>从以上特点，整个消息系统足够简单，<strong>不考虑扩缩容问题</strong>，当系统负载到达极限的时候，就<strong>重新再部署一套系统</strong>以应对后端client的消息压力。</p>

<p>这种处理方式本质是把系统的扩容能力甩锅给了后端Client以及前端Gateway：<strong>每次扩容一个系统，所有Client需要在本地配置文件中添加一个Proxy地址然后全部重启，所有Gateway则需要再本地配置文件添加一个Router地址然后全部重启。</strong></p>

<p>这种“幸福我一人，辛苦千万家”的扩容应对方式，必然导致公司内部这套系统的使用者怨声载道，升级之路就是必然的了。</p>

<h3 id="toc_2">2 可扩展</h3>

<hr>

<p>大道之行也，天下为公，不同的系统有不同的构架，相同的系统总有类似的实现。类似于数据库的分库分表【关于分库分表，目前看到的最好的文章是参考文档1】，其扩展实现核心思想是分Partition分Replica，但各Replica之间还区分leader（leader-follower，只有leader可接受写请求）和non-leader（所有replica均可接收写请求）两种机制。</p>

<p>从数据角度来看，这套系统接收两种消息：Room Message（房间聊天消息）和Gateway Message（用户登录消息）。两种消息的交汇之地就是Broker，所以应对扩展的紧要地方就是Broker，Broker的每个Partition采用non-leader机制，各replica均可接收Gateway Message消息写请求和Room Message转发请求。</p>

<p>首先，当Room Message量加大时可以对Proxy进行水平扩展，多部署Proxy即可因应Room Message的流量。</p>

<p>其次，当Gateway Message量加大时可以对Router进行水平扩展，多部署Router即可因应Gateway Message的流量。</p>

<p>最后，两种消息的交汇之地Broker如何扩展呢？可以把若干Broker Replica组成一个Partition，因为Gateway Message是在一个Partition内广播的，所有Broker Replica都会复制一份Gateway message以组织Room Id和Gateway IP&amp;port的映射关系，因此当Gateway message增加时扩容Partition即可。当Room Message量增加时，水平扩容Partition内的Broker Replica即可，因为Room Message只会发送到Partition内某个Replica上。</p>

<p>从个人经验来看，Room ID的增长以及Room内成员的增加量在一段时间内可以认为是直线增加，而Room Message可能会以指数级增长，所以若设计得当则Partition扩容的概率很小，而Partition内Replica水平增长的概率几乎是100%。</p>

<p>不管是Partition级别的水平扩容还是Partition Replica级别的水平扩容，不可能像系统极简版本那样每次扩容后都需要Client或者Gateway去更新配置文件然后重启，因应之道就是可用zookeeper充当角色的Registriy。通过这个zookeeper注册中心，相关角色扩容的时候在Registry注册后，与之相关的其他模块得到通知即可获取其地址等信息。采用zookeeper作为Registry的时候，所以程序实现的时候采用实时watch和定时轮询的策略保证数据可靠性，因为一旦网络有任何的抖动，zk就会认为客户端已经宕机把链接关闭。</p>

<p>分析完毕，与之相对的架构图如下：</p>

<p><img src="../pic/pubsub_scalable.png" alt=""></p>

<p>分章节描述各个模块详细流程。</p>

<h4 id="toc_3">2.1 Client</h4>

<hr>

<p>Client详细流程如下：</p>

<ul>
<li>1 从配置文件加载Registry地址；</li>
<li>2 从Registy上Proxy注册路径/pubsub/proxy下获取所有的Proxy，依据各个Proxy ID大小顺序递增组成一个ProxyArray；</li>
<li>3 启动一个线程实时关注Registry路径/pubsub/proxy，以获取Proxy的动态变化，及时更新ProxyArray；</li>
<li>4 启动一个线程定时轮询获取Registry路径/pubsub/proxy下各个Proxy实例，作为关注策略的补充，以期本地ProxyArray内各个Proxy成员与Registry上的各个Proxy保持一致；定时给各个Proxy发送心跳，异步获取心跳回包；定时清除ProxyArray中心跳超时的Proxy成员；</li>
<li>5 发送消息的时候采用snowflake算法给每个消息分配一个MessageID，然后采用相关负载均衡算法把消息转发给某个Proxy。</li>
</ul>

<h4 id="toc_4">2.2 Proxy</h4>

<hr>

<p>Proxy详细流程如下：</p>

<ul>
<li>1 读取配置文件，获取Registry地址；</li>
<li>2 把自身信息注册到Registry路径/pubsub/proxy下，把Registry返回的ReplicaID作为自身ID；</li>
<li>3 从Registry路径/pubsub/broker/partition(x)下获取每个Broker Partition的各个replica；</li>
<li>4 从Registry路径/pubsub/broker/partition_num获取当前有效的Broker Partition Number；</li>
<li><p>5 启动一个线程关注Registry上的Broker路径/pubsub/broker，以实时获取以下信息：</p>

<div><pre><code class="language-none">Broker Partition Number；
新的Broker Partition（此时发生了扩容）；
Broker Partition内新的broker replica（Partition内发生了replica扩容）；
Broker Parition内某replica挂掉的信息；</code></pre></div></li>
<li><p>6 定时向各个Broker Partition replica发送心跳，异步等待Broker返回的心跳响应包，以探测其活性，以保证不向超时的replica转发Room Message；</p></li>
<li><p>7 启动一个线程定时读取Registry上的Broker路径/pubsub/broker下各个子节点的值，以定时轮询的策略观察Broker Partition Number变动，以及各Partition的变动情况，作为实时策略的补充；同时定时检查心跳包超时的Broker，从有效的BrokerList中删除；</p></li>
<li><p>8 依据规则【BrokerPartitionID = RoomID % BrokerPartitionNum， BrokerReplicaID = roomID % BrokerPartitionReplicaNum】向某个Partition的replica转发Room Message，收到Client的Heatbeat包时要及时给予响应。</p></li>
</ul>

<p><font color=blue><strong>之所以把Room Message和Heartbeat Message放在一个线程处理，是为了防止进程假死这种情况。</strong></font></p>

<p>当/pubsub/broker/partition_num的值发生改变的时候(譬如值改为4)，意味着Router Partition进行了扩展，Proxy要及时获取新Partition路径（如/pubsub/broker/Partition2和/pubsub/broker/Partition3）下的实例，并关注这些路径，获取新Partition下的实例。</p>

<p>之所以Proxy在获取Registry下所有当前的Broker实例信息后再注册自身信息，是因为此时它才具有转发消息的资格。</p>

<p>Proxy转发某个Room消息时候，只发送给处于Running状态的Broker。为Broker Partition内所有replica依据Registry给其分配的replicaID进行递增排序，组成一个Broker Partition Replica Array，规则中BrokerPartitionReplicaNum为Array的size，而BrokerReplicaID为replica在Array中的下标。</p>

<h4 id="toc_5">2.3 Broker</h4>

<hr>

<p>Broker详细流程如下：</p>

<ul>
<li>1 Broker加载配置，获取自身所在Partition的ID（假设为3）；</li>
<li>2 向Registry路径/pubsub/broker/partition3注册，设置其状态为Init，注册中心返回的ID作为自身的ID(replicaID)；</li>
<li>3 接收Router转发来的Gateway Message，放入GatewayMessageQueue；</li>
<li>4 从Database加载数据，把自身所在的Broker Partition所应该负责的Room ID到某Gateway映射数据加载进来；</li>
<li>5 异步处理GatewayMessageQueue内的Gateway Message，只处理满足规则【PartitionID == RoomID % PartitionNum】的消息，把数据存入本地路由信息缓存；</li>
<li>6 修改Registry路径/pubsub/broker/partition3下自身节点的状态为Running；</li>
<li>7 启动线程实时关注Registry路径/pubsub/broker/partition_num的值；</li>
<li>8 启动线程定时查询Registry路径/pubsub/broker/partition_num的值；</li>
<li>9 当Registry路径/pubsub/broker/partition_num的值发生改变的时候，依据规则【PartitionID == RoomID % PartitionNum】清洗本地路由信息缓存中每条数据；</li>
<li>10 接收Proxy发来的Room Message，依据RoomID从路由信息缓存中查找Room有成员登陆的所有Gateway，把消息转发给这些Gateway；</li>
</ul>

<p>注意Broker之所以先注册然后再加载Database中的数据，是为了在加载数据的时候同时接收Router转发来的Gateway Message，但是在数据加载完前这些受到的数据先被缓存起来，待映射关系加载完后就把这些数据重放一遍；</p>

<p>Broker之所以区分状态，是为了在加载完毕映射关系前不对Proxy提供转发消息的服务，同时也方便Broker Partition应对的消息量增大时进行水平扩展。</p>

<p>当Broker发生Partition扩展的时候，新的Partition个数必须是2的幂，只有新Partition内所有Broker Replica都加载实例完毕，再更改/pubsub/broker/partition_num的值。</p>

<p>老的Broker也要watch路径/pubsub/broker/partition_num的值，当这个值增加的时候，它也需要清洗本地的路由信息缓存。</p>

<p>Broker的扩容过程犹如细胞分裂，形成中的两个细胞有着完全相同的数据，分裂完成后【Registry路径/pubsub/broker/partition_num的值翻倍】则需要清洗垃圾信息。</p>

<h4 id="toc_6">2.4 Router</h4>

<hr>

<p>Router详细流程如下：</p>

<ul>
<li>1 Router加载配置，Registry地址；</li>
<li>2 把自身信息注册到Registry路径/pubsub/router下，把Registry返回的ReplicaID作为自身ID；</li>
<li>3 从Registry路径/pubsub/broker/partition(x)下获取每个Broker Partition的各个replica；</li>
<li>4 从Registry路径/pubsub/broker/partition_num获取当前有效的Broker Partition Number；</li>
<li><p>5 启动一个线程关注Registry上的Broker路径/pubsub/broker，以实时获取以下信息：</p>

<div><pre><code class="language-none">Broker Partition Number；
新的Broker Partition（此时发生了扩容）；
Broker Partition内新的broker replica（Partition内发生了replica扩容）；
Broker Parition内某replica挂掉的信息；</code></pre></div></li>
<li><p>6 定时向各个Broker Partition replica发送心跳，异步等待Broker返回的心跳响应包，以探测其活性，以保证不向超时的replica转发Gateway Message；</p></li>
<li><p>7 启动一个线程定时读取Registry上的Broker路径/pubsub/broker下各个子节点的值，以定时轮询的策略观察Broker Partition Number变动，以及各Partition的变动情况，作为实时策略的补充；同时定时检查心跳包超时的Broker，从有效的BrokerList中删除；</p></li>
<li><p>8 从Database全量加载路由映射数据放入本地缓存；</p></li>
<li><p>9 收取Gateway发来的心跳消息，及时返回ack包；</p></li>
<li><p>10 收取Gateway转发来的Gateway Message，按照一定规则【BrokerPartitionID % BrokerPartitionNum = RoomID % BrokerPartitionNum】转发给<font color=blue><strong>某个Broker Partition下所有Broker Replica</strong></font>，保证Partition下所有replica拥有同样的路由映射数据，再把Message内数据存入本地缓存，当检测到数据不重复的时候把数据异步写入Database； </p></li>
</ul>

<h4 id="toc_7">2.5 Gateway</h4>

<hr>

<p>Gateway详细流程如下：</p>

<ul>
<li>1 读取配置文件，加载Registry地址；</li>
<li>2 从Registry路径/pubsub/router/下获取所有router replica，依据各Replica的ID递增排序组成replica数组RouterArray；</li>
<li>3 启动一个线程实时关注Registry路径/pubsub/router，以获取Router的动态变化，及时更新RouterArray；</li>
<li>4 启动一个线程定时轮询获取Registry路径/pubsub/router下各个Router实例，作为关注策略的补充，以期本地RouterArray及时更新；定时给各个Router发送心跳，异步获取心跳回包；定时清除RouterArray中心跳超时的Router成员；</li>
<li>5 当有Room内某成员客户端连接上来或者Room内所有成员都不连接当前Gateway节点时，依据规则【RouterArrayIndex = RoomID % RouterNum】向某个Router发送Gateway Message；</li>
<li>6 收到Broker转发来的Room Message时，根据MessageID进行去重，如果不重复则把消息发送到连接到当前Gateway的Room内所有客户端，同时把MessageID缓存起来以用于去重判断。</li>
</ul>

<p>Gateway本地有一个基于共享内存的LRU Cache，存储最近一段时间发送的消息的MessageID。</p>

<h3 id="toc_8">3 系统稳定性</h3>

<hr>

<p>系统具有了可扩展性仅仅是系统可用的初步，整个系统要保证最低粒度的SLA（0.99），就必须在两个维度对系统的可靠性就行感知：消息延迟和系统内部组件的高可用。</p>

<h4 id="toc_9">3.1 消息延迟</h4>

<hr>

<p>准确的消息延迟的统计，通用的做法可以基于日志系统对系统所有消息或者以一定概率抽样后进行统计，但限于人力目前没有这样做。</p>

<p>目前使用了一个方法：通过一种构造一组伪用户ID，定时地把消息发送给proxy，每条消息经过一层就把在这层的进入时间和发出时间以及组件自身的一些信息填入消息，这组伪用户的消息最终会被发送到一个伪Gateway端，伪Gateway对这些消息的信息进行归并统计后，即可计算出当前系统的平均消息延迟时间。</p>

<p>通过所有消息的平均延迟可以评估系统的整体性能。同时，因为系统消息路由的哈希方式已知，当固定时间内伪Gateway没有收到消息时，就把消息当做发送失败，当某条链路失败一定次数后就可以产生告警了。</p>

<h4 id="toc_10">3.2 高可用</h4>

<hr>

<p>上面的方法同时能够检测某个链路是否出问题，但是链路具体出问题的点无法判断，且实时性无法保证。</p>

<p>为了保证各个组件的高可用，系统引入了另一种评估方法：每个层次都给后端组件发送心跳包，通过心跳包的延迟和成功率判断其下一级组件的当前的可用状态。</p>

<p>譬如proxy定时给每个Partition内每个broker发送心跳，可以依据心跳的成功率来快速判断broker是否处于“假死”状态（最近业务就遇到过broker进程还活着，但是对任何收到的消息都不处理的情况）。</p>

<p>同时依靠心跳包的延迟还可以判断broker的处理能力，基于此延迟值可在同一Partition内多broker端进行负载均衡。</p>

<h3 id="toc_11">4 消息可靠性</h3>

<hr>

<p>公司内部内部原有一个走tcp通道的pubsub系统，但是经过元旦一次大事故（几乎全线崩溃）后，相关业务的一些重要消息改走这套基于UDP的pubsub系统了。这些消息如服务端下达给客户端的游戏动作指令，是不允许丢失的，但其特点是相对于聊天消息来说量非常小（单人1秒最多一个），所以需要在目前UDP链路传递消息的基础之上再构建一个可靠消息链路。</p>

<p>国内某IM大厂的消息系统也是以UDP链路为基础的，他们的做法是消息重试加ack构建了可靠消息稳定传输链路。但是这种做法会降低系统的吞吐率，所以需要独辟蹊径。</p>

<p>UDP通信的本质就是伪装的IP通信，TCP自身的稳定性无非是重传、去重和ack，所以不考虑消息顺序性的情况下可以通过重传与去重来保证消息的可靠性。</p>

<p>基于目前系统的可靠消息传输流程如下：  </p>

<ul>
<li>1 Client给每个命令消息依据snowflake算法配置一个ID，复制三份，立即发送给不同的Proxy；<br></li>
<li>2 Proxy收到命令消息以后随机发送给一个Broker；<br></li>
<li>3 Broker收到后传输给Gateway；<br></li>
<li>4 Gateway接收到命令消息后根据消息ID进行重复判断，如果重复则丢弃，否则就发送给APP，并缓存之。</li>
</ul>

<p>正常的消息在pubsub系统中传输时，Proxy会根据消息的Room ID传递给固定的Broker，以保证消息的有序性。</p>

<h3 id="toc_12">5 多pubsub集群下的独立Router</h3>

<hr>

<p>当线上需要部署多套pubsub系统的时候，Gateway需要把同样的Room Message复制多份转发给多套pubsub系统，会增大Gateway压力，可以把Router单独独立部署，然后把Room Message向所有的pubsub系统转发。</p>

<p>Router系统原有流程是：Gateway按照Room ID把消息转发给某个Router，然后Router把消息转发给下游Broker实例。新部署一套pubsub系统的时候，新系统Broker的schema需要通过一套约定机制通知Router，使得Router自身逻辑过于复杂。</p>

<p><img src="../pic/pubsub_router.png" alt=""></p>

<p>重构后的Router也采用分Partition分Replica设计，Partition内部各Replica之间采用non-leader机制；各Router Replica不会主动把Gateway Message内容push给各Broker，而是各Broker主动通过心跳包形式向Router Partition内某个Replica注册，而后此Replica才会把消息转发到这个Broker上。</p>

<p>类似于Broker，Router Partition也以2倍扩容方式进行Partition水平扩展，并通过一定机制保证扩容或者Partition内部各个实例停止运行或者新启动时，尽力保证数据的一致性。</p>

<p>Router Replica收到Gateway Message后，replica先把Gateway Message转发给Partition内各个peer replica，然后再转发给各个订阅者。Router转发消息的同时异步把消息数据写入Database。</p>

<p>独立Router架构下，下面分别详述Gateway、Router和Broker三个相关模块的详细流程。</p>

<h4 id="toc_13">5.1 Gateway</h4>

<hr>

<p>Gateway详细流程如下：</p>

<ul>
<li>1 从Registry路径/pubsub/router/partition(x)下获取每个Partition的各个replica；</li>
<li>2 从Registry路径/pubsub/router/partition_num获取当前有效的Router Partition Number；</li>
<li><p>3 启动一个线程关注Registry上的Router路径/pubsub/router，以实时获取以下信息：</p>

<div><pre><code class="language-none">Router Partition Number；
新的Router Partition（此时发生了扩容）；
Partition内新的replica（Partition内发生了replica扩容）；
Parition内某replica挂掉的信息；</code></pre></div></li>
<li><p>4 定时向各个Partition replica发送心跳，异步等待Router返回的心跳响应包，以探测其活性，以保证不向超时的replica转发Gateway Message；</p></li>
<li><p>4 启动一个线程定时读取Registry上的Router路径/pubsub/router下各个子节点的值，以定时轮询的策略观察Router Partition Number变动，以及各Partition的变动情况，作为实时策略的补充；同时定时检查心跳包超时的Router，从有效的BrokerList中删除；</p></li>
<li><p>6 依据规则向某个Partition的replica转发Gateway Message；</p></li>
</ul>

<p>第六步的规则决定了Gateway Message的目的Partition和replica，规则内容有：</p>

<blockquote>
<p>如果某Router Partition ID满足condition(RoomID % RouterPartitionNumber == RouterPartitionID % RouterPartitionNumber)，则把消息转发到此Partition；</p>

<blockquote>
<blockquote>
<p>这里之所以不采用直接hash方式(RouterPartitionID = RoomID % RouterPartitionNumber)获取Router Partition，是考虑到当Router进行2倍扩容的时候当所有新的Partition的所有Replica都启动完毕且数据一致时才会修改Registry路径/pubsub/router/partition<em>num的值，按照规则的计算公式才能保证新Partition的各个Replica在启动过程中就可以得到Gateway Message，也即此时每个Gateway Message会被发送到两个Router Partition。
当Router扩容完毕，修改Registry路径/pubsub/router/partition</em>num的值后，此时新集群进入稳定期，每个Gateway Message只会被发送固定的一个Partition，condition(RoomID % RouterPartitionNumber == RouterPartitionID % RouterPartitionNumber)等效于condition(RouterPartitionID = RoomID % RouterPartitionNumber)。</p>
</blockquote>
</blockquote>

<p>如果Router Partition内某replia满足condition(replicaPartitionID = RoomID % RouterPartitionReplicaNumber)，则把消息转发到此replica。</p>

<blockquote>
<blockquote>
<p>replica向Registry注册的时候得到的ID称之为replicaID，Router Parition内所有replica按照replicaID递增排序组成replica数组RouterPartitionReplicaArray，replicaPartitionID即为replica在数组中的下标。</p>
</blockquote>
</blockquote>
</blockquote>

<h4 id="toc_14">5.2 Router</h4>

<hr>

<p>Router系统部署之前，先设置Registry路径/pubsub/router/partition_num的值为1。</p>

<p>Router详细流程如下：</p>

<ul>
<li>1 Router加载配置，获取自身所在Partition的ID（假设为3）；</li>
<li>2 向Registry路径/pubsub/router/partition3注册，设置其状态为Init，注册中心返回的ID作为自身的ID(replicaID)；</li>
<li>3 注册完毕会收到Gateway发来的Gateway Message以及Broker发来的心跳消息（HeartBeat Message），先缓存到消息队列MessageQueue；</li>
<li>4 从Registry路径/pubsub/router/partition3下获取自身所在的Partition内的各个replica；</li>
<li>5 从Registry路径/pubsub/router/partition_num获取当前有效的Router Partition Number；</li>
<li><p>6 启动一个线程关注Registry路径/pubsub/router，以实时获取以下信息：</p>

<div><pre><code class="language-none">Router Partition Number；
Partition内新的replica（Partition内发生了replica扩容）；
Parition内某replica挂掉的信息；</code></pre></div></li>
<li><p>7 从Database加载数据；</p></li>
<li><p>8 启动一个线程异步处理MessageQueue内的Gateway Message，把Gateway Message转发给同Partition内其他peer replica，然后依据规则【RoomID % BrokerPartitionNumber == BrokerReplicaPartitionID % BrokerPartitionNumber】转发给BrokerList内每个Broker；处理Broker发来的心跳包，把Broker的信息存入本地BrokerList，然后给Broker发送回包；</p></li>
<li><p>9 修改Registry路径/pubsub/router/partition3下节点的状态为Running；</p></li>
<li><p>10 启动一个线程定时读取Registry路径/pubsub/router下各个子路径的值，以定时轮询的策略观察Router各Partition的变动情况，作为实时策略的补充；检查超时的Broker，把其从BrokerList中剔除；</p></li>
<li><p>11 当RouterPartitionNum倍增时，Router依据规则【RoomID % BrokerPartitionNumber == BrokerReplicaPartitionID % BrokerPartitionNumber】清洗自身路由信息缓存中数据。</p></li>
</ul>

<p>之所以把Gateway Message和Heartbeat Message放在一个线程处理，是为了防止进程假死这种情况。</p>

<p>Broker也采用了分Partition分Replica机制，所以向Broker转发Gateway Message时候路由规则，与Gateway向Router转发消息的路由规则相同。</p>

<p>另外启动一个工具，当水平扩展后新启动的Partition内所有Replica的状态都是Running的时候，修改Registry路径/pubsub/router/partition_num的值为所有Partition的数目。</p>

<h4 id="toc_15">5.3 Broker</h4>

<hr>

<p>Broker详细流程如下：</p>

<ul>
<li>1 Broker加载配置，获取自身所在Partition的ID（假设为3）；</li>
<li>2 向Registry路径/pubsub/broker/partition3注册，设置其状态为Init，注册中心返回的ID作为自身的ID(replicaID)；</li>
<li>3 从Registry路径/pubsub/router/partition_num获取当前有效的Router Partition Number；</li>
<li>4 从Registry路径/pubsub/router/partition(x)下获取每个Router Partition的各个replica；</li>
<li><p>5 启动一个线程关注Registry路径/pubsub/router，以实时获取以下信息：</p>

<div><pre><code class="language-none">Router Partition Number；
新的Router Partition（此时发生了扩容）；
Partition内新的replica（Partition内发生了replica扩容）；
Parition内某replica挂掉的信息；</code></pre></div></li>
<li><p>6 依据规则【RouterPartitionID % BrokerPartitionNum == BrokerPartitionID % BrokerPartitionNum，RouterReplicaID = BrokerReplicaID % BrokerPartitionNum】选定目标Router Partition下某个Router replica，向其发送心跳消息，包含BrokerPartitionNum、BrokerPartitionID、BrokerHostAddr和精确到秒级的Timestamp，并异步等待所有Router replica的回复，所有Router转发来的Gateway Message放入GatewayMessageQueue；</p></li>
<li><p>7 依据规则【BrokerPartitionID == RoomID % BrokerParitionNum】从Database加载数据；</p></li>
<li><p>8 依据规则【BrokerPartitionID % BrokerParitionNum == RoomID % BrokerParitionNum】异步处理GatewayMessageQueue内的Gateway Message，只留下合乎规则的消息的数据；</p></li>
<li><p>9 修改Registry路径/pubsub/broker/partition3下自身节点的状态为Running；</p></li>
<li><p>10 启动一个线程定时读取Registry路径/pubsub/router下各个子路径的值，以定时轮询的策略观察Router各Partition的变动情况，作为实时策略的补充；定时检查超时的Router，某Router超时后更换其所在的Partition内其他Router替换之，定时发送心跳包；</p></li>
<li><p>11 当Registry路径/pubsub/broker/partition_num的值BrokerPartitionNum发生改变的时候，依据规则【PartitionID == RoomID % PartitionNum】清洗本地路由信息缓存中每条数据；</p></li>
<li><p>12 接收Proxy发来的Room Message，依据RoomID从路由信息缓存中查找Room有成员登陆的所有Gateway，把消息转发给这些Gateway；</p></li>
</ul>

<p>BrokerPartitionNumber可以小于或者等于或者大于RouterPartitionNumber，两个数应该均是2的幂，两个集群可以分别进行扩展，互不影响。譬如BrokerPartitionNumber=4而RouterPartitionNumber=2，则Broker Partition 3只需要向Router Partition 1的某个follower发送心跳消息即可；若BrokerPartitionNumber=4而RouterPartitionNumber=8，则Broker Partition 3需要向Router Partition 3的某个follower发送心跳消息的同时，还需要向Router Partition 7的某个follower发送心跳，以获取全量的Gateway Message。</p>

<p>Broker需要关注/pubsub/router/partition<em>num和/pubsub/broker/partition</em>num的值的变化，当router或者broker进行parition水平扩展的时候，Broker需要及时重新构建与Router之间的对应关系，及时变动发送心跳的Router Replica对象【RouterPartitionID = BrokerReplicaID % RouterPartitionNum，RouterPartitionID为Router Replica在PartitionRouterReplicaArray数组的下标】。</p>

<p>当Router Partition内replica死掉或者发送心跳包的replica对象死掉（无论是注册中心通知还是心跳包超时），broker要及时变动发送心跳的Router replica对象。</p>

<p>另外，Gateway使用UDP通信方式向Router发送Gateway Message，如若这个Message丢失则此Gateway上该Room内所有成员一段时间内（当有新的成员在当前Gateway上加入room
时会产生新的Gateway Message）都无法再接收消息，为了保证消息的可靠性，可以使用这样一个约束解决问题：<font color=blue><strong>在此Gateway上登录的某Room内的人数少于3时，Gateway会把Gateway Message复制两份非连续（如以10ms为时间间隔）重复发送给某个Partition leader。</strong></font>因Gateway Message消息处理的幂等性，重复Gateway Message并不会导致Room Message发送错误，只在极少概率的情况下会导致Gateway收到消息的时候Room内已经没有成员在此Gateway登录，此时Gateway会把消息丢弃不作处理。</p>

<h3 id="toc_16">6 总结</h3>

<hr>

<p>这套pubsub系统尚有以下task lisk需完善：</p>

<ul>
<li>1 消息以UDP链路传递，不可靠【2018/01/29解决之】；</li>
<li>2 目前的负载均衡算法采用了极简的RoundRobin算法，可以根据成功率和延迟添加基于权重的负载均衡算法实现；</li>
<li>3 只考虑传递，没有考虑消息的去重，可以根据消息ID实现这个功能【2018/01/29解决之】；</li>
<li>4 各个模块之间没有考虑心跳方案，整个系统的稳定性依赖于Registry【2018/01/17解决之】；</li>
</ul>

<p>此记。</p>

<h2 id="toc_17">参考文档</h2>

<ul>
<li>1 <a href="http://blog.csdn.net/bluishglc/article/details/7970268">一种支持自由规划无须数据迁移和修改路由代码的Replicaing扩容方案</a></li>
</ul>

<h2 id="toc_18">扒粪者-于雨氏</h2>

<blockquote>
<p>于雨氏，2017/12/31，初作此文于丰台金箱堂。</p>

<p>于雨氏，2018/01/16，于海淀添加“系统稳定性”一节。</p>

<p>于雨氏，2018/01/29，于海淀添加“消息可靠性”一节。</p>

<p>于雨氏，2018/02/11，于海淀添加“Router”一节，并重新格式化全文。</p>
</blockquote>


<div id="disqus_thread"></div>
<script type="text/javascript">
// disqus comment js block, added on 2016/02/10
// https://segmentfault.com/a/1190000002807674
var disqus_shortname = 'alexstocks'; // Required - Replace example with your forum shortname
var disqus_identifier = window.location.pathname; //'a unique identifier for each page where Disqus is present';
var disqus_title = document.title; // 'a unique title for each page where Disqus is present';
var disqus_url = document.URL; // window.location.origin + window.location.pathname; // 'a unique URL for each page where Disqus is present';
var disqus_config = function () {
this.page.url = window.location.href; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = window.location.pathname; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
(function() {
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; dsq.setAttribute('data-timestamp', +new Date());
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script id="dsq-count-scr" src='//' + disqus_shortname + '.disqus.com/count.js' async></script>


</body>

</html>
