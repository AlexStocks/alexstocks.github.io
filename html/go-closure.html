<!DOCTYPE html>
<html>
<head>
<title>go-closure</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child,
ol li > :first-child,
ul li ul:first-of-type,
ol li ol:first-of-type,
ul li ol:first-of-type,
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>Golang之闭包</h2>
<hr />
<p><em>written by Alex Stocks on 2016/09/24</em></p>
<h3>1 closure定义</h3>
<hr />
<p>关于closure的定义，可以参照golang官方示例（参考文档1）中的一句话：</p>
<blockquote>
<p>Go supports anonymous functions, which can form closures. Anonymous functions are useful when you want to define a function inline without having to name it.</p>
</blockquote>
<p>从上面这句话可以看出看出，closure首先是匿名函数，其次是在另一个函数里面实现。</p>
<p>很多语言都有closure，其实都是一种语法糖，它与其定义时所在的函数共享同一个函数栈，能够使用其所在函数的内存空间，其访问的内存空间的对象(可称之为closure context)会被runtime放在堆空间上，编译器编译closure后会被inline成所在函数的一部分语句块(golang中是Escape Analysis技术)以提高运行速度。</p>
<p>其实可以这么定义：closure = anonymous function + closure conetxt。关于closure的汇编层面解释，详见最下面列出的参考文档2。</p>
<p>下面列述最近遇到的几个比较典型的golang clousure code example。</p>
<h3>2 closure与引用</h3>
<hr />
<p>golang中通过传递变量值能够起到引用效果的变量类型有slice &amp; map &amp; channel，其本质是这三种var type不是那种类似于int等可以让CPU直接访问的原子变量类型，而是一种C中的类似于struct的复合数据结构，其结构体中存储的值又指向的更大的一块内存地址，这个大内存区域才是真正的“值域”，结构体本身类似域大内存域的proxy。如果能够理解C++的shared_ptr的实现，就能够理解这种变量类型的本质。</p>
<p>因为closure与其所在的函数共享函数栈，所以也能实现类似于引用的效果。如下程序：</p>
<pre><code>// output: 5
func main() {
    var v int = 3
    func() {
        v = 5
    }()
    println(v)
}
</code></pre>

<p>上面的例子中，main函数内部的closure修改了变量v的值，因为是函数内部调用，其结论可能不能为人信服，又有如下示例：</p>
<pre><code>// output: 5
func test() (func(), func()) {
    var v int = 3
    return func() { v = 5 }, func() { println(&quot;v:&quot;, v) }
}

func main() {
    f1, f2 := test()
    f1()
    f2()
}
</code></pre>

<p>代码示例中f1和f2访问的变量v，其实v在使用时被runtime定义在了heap上。</p>
<p>参考文档1的代码示例也比较经典，一并补录如下：</p>
<pre><code>func intSeq() func() int {
    i := 0
    return func() int {
        i += 1
        return i
    }
}

func main() {
    nextInt := intSeq()

    println(nextInt()) // 1
    println(nextInt()) // 2
    println(nextInt()) // 3

    newInts := intSeq()
    println(newInts()) // 1
}
</code></pre>

<p>注意上面示例中最后一行的输出，当closure所在函数重新调用时，其closure是新的，其context引用的变量也是重新在heap定义过的。</p>
<h3>3 closure与context</h3>
<hr />
<p>context是我见过的golang标准库(go1.7)中最优雅的库之一，对context的分析详见参考文档3，其cancel相关代码如下：</p>
<pre><code>type CancelFunc func()

// WithCancel方法返回一个继承自parent的Context对象，同时返回的cancel方法可以用来关闭返回的Context当中的Done channel
// 其将新建立的节点挂载在最近的可以被cancel的父节点下（向下方向）
// 如果传入的parent是不可被cancel的节点，则直接只保留向上关系
func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
    c := newCancelCtx(parent)
    propagateCancel(parent, &amp;c)
    return &amp;c, func() { c.cancel(true, Canceled) }
}

func newCancelCtx(parent Context) cancelCtx {
    return cancelCtx{
        Context: parent,
        done:    make(chan struct{}),
    }
}
</code></pre>

<p>从上可见cancel context也用到了closure，WithCancel返回了一个context对象和一个closure。cancel context的使用示例(参考文档4)如下：</p>
<pre><code>// 模拟一个最小执行时间的阻塞函数
func inc(a int) int {
    res := a + 1                // 虽然我只做了一次简单的 +1 的运算,
    time.Sleep(1 * time.Second) // 但是由于我的机器指令集中没有这条指令,
    // 所以在我执行了 1000000000 条机器指令, 续了 1s 之后, 我才终于得到结果。B)
    return res
}

// 向外部提供的阻塞接口
// 计算 a + b, 注意 a, b 均不能为负
// 如果计算被中断, 则返回 -1
func Add(ctx context.Context, a, b int) int {
    res := 0
    for i := 0; i &lt; a; i++ {
        res = inc(res)
        select {
        case &lt;-ctx.Done():
            return -1
        default:
        }
    }
    for i := 0; i &lt; b; i++ {
        res = inc(res)
        select {
        case &lt;-ctx.Done():
            return -1
        default:
        }
    }

    return res
}

// output:
// Compute: 1+2, result: -1
// Compute: 1+2, result: -1
func main() {
    // 手动取消
    a := 1
    b := 2
    ctx, cancel := context.WithCancel(context.Background())
    go func() {
        time.Sleep(2 * time.Second)
        cancel() // 在调用处主动取消
    }()
    res := Add(ctx, 1, 2)
}
</code></pre>

<h3>4 closure与error</h3>
<hr />
<p>golang中错误处理是一件令人头疼的事情：需要不断的写&quot;if err != nil {}&quot;这样的代码^_^。</p>
<p>golang官方的《Errors are values》(参考文档5)一文中给出了如下一段错误处理示例：</p>
<pre><code>_, err = fd.Write(p0[a:b])
if err != nil {
    return err
}
_, err = fd.Write(p1[c:d])
if err != nil {
    return err
}
_, err = fd.Write(p2[e:f])
if err != nil {
    return err
}
// and so on
</code></pre>

<p>这段代码示例的机巧之处在于:三个错误处理针对同一个函数fd.Write，这便能通过closure上下其手了，官方给出的第一个改进就是：</p>
<pre><code>var err error
write := func(buf []byte) {
    if err != nil {
        return
    }
    _, err = w.Write(buf)
}
write(p0[a:b])
write(p1[c:d])
write(p2[e:f])
// and so on
if err != nil {
    return err
}
</code></pre>

<p>上面write closure虽然没有减少代码量，但使得代码优雅了不少。后面官方又给出了第二个优化：</p>
<pre><code>type errWriter struct {
    w   io.Writer
    err error
}

func (ew *errWriter) write(buf []byte) {
    if ew.err != nil {
        return
    }
    _, ew.err = ew.w.Write(buf)
}

ew := &amp;errWriter{w: fd}
ew.write(p0[a:b])
ew.write(p1[c:d])
ew.write(p2[e:f])
// and so on
if ew.err != nil {
    return ew.err
}
</code></pre>

<p>这个代码示例把closure中的error放入了struct errWriter之中，使得代码更加精妙。</p>
<p>上面代码段中这个技巧被用到了bufio.Writer的实现上，所以调用(bufio.Writer)Write函数时候，不用不断检查其返回值error，其代码示例如下：</p>
<pre><code>b := bufio.NewWriter(fd)
b.Write(p0[a:b])
b.Write(p1[c:d])
b.Write(p2[e:f])
// and so on
if b.Flush() != nil {
    return b.Flush()
}
</code></pre>

<p>本节的技巧只有在同一个函数接口以及同一个处理对象error这样的情况下才可使用。</p>
<h3>6 总结</h3>
<hr />
<p>本文总结了closure的本质以及其一些使用场景，囿于个人golang知识范围低下，暂时只能写这么多了。</p>
<p>以后随着个人能力提升，我会逐渐补加此文。</p>
<p>此记。</p>
<h2>参考文档</h2>
<hr />
<ul>
<li>1 <a href="https://gobyexample.com/closures">Go by Example: Closures</a></li>
<li>2 <a href="http://sunisdown.me/closures-in-go.html">Closures in Go</a></li>
<li>3 <a href="http://studygolang.com/articles/5131">go程序包源码解读——golang.org/x/net/context</a></li>
<li>4 <a href="http://ju.outofmemory.cn/entry/273349">golang中context包解读</a></li>
<li>5 <a href="https://blog.golang.org/errors-are-values">Errors are values</a></li>
</ul>
<h2>扒粪者-于雨氏</h2>
<blockquote>
<p>于雨氏，2016/09/24，初作此文于东沪。</p>
</blockquote>

<div id="disqus_thread"></div>
<script type="text/javascript">
// disqus comment js block, added on 2016/02/10
// https://segmentfault.com/a/1190000002807674
var disqus_shortname = 'alexstocks'; // Required - Replace example with your forum shortname
var disqus_identifier = window.location.pathname; //'a unique identifier for each page where Disqus is present';
var disqus_title = document.title; // 'a unique title for each page where Disqus is present';
var disqus_url = document.URL; // window.location.origin + window.location.pathname; // 'a unique URL for each page where Disqus is present';
var disqus_config = function () {
this.page.url = window.location.href; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = window.location.pathname; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() {
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; dsq.setAttribute('data-timestamp', +new Date());
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script id="dsq-count-scr" src='//' + disqus_shortname + '.disqus.com/count.js' async></script>

</body>
</html>
