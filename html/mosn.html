<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>mosn</title>


<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb
}

* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
  body {
    padding: 2cm;
  }
}
</style>


</head>

<body>

<h1 id="toc_0">SOFAMosn 笔记</h1>

<hr>

<p><em>written by Alex Stocks on 2019/07/06，版权所有，无授权不得转载</em></p>

<p>关于 SOFAMosn 与愚人的故事，须从 2018 年 9 月 16 日说起。此日在离京南下某地参加毕业 X 周年聚会的火车途中，dubbogo QQ 群群友 老C 发来一条连接，说是其参与的一个叫做 <a href="(https://github.com/sofastack/sofa-mosn)">SOFAMosn</a> 的开源项目使用了愚人的 <a href="(https://github.com/dubbogo/hessian2)">dubbogo/hessian2</a> 项目，以与 <a href="(github.com/apache/dubbo)">apache/dubbo</a> 进行通信。</p>

<p>老C顺便提及，项目由其所在的阿里大文娱UC事业部和蚂蚁金服共建。既然是大厂出品，愚人便兴起翻阅了下此项目，彼时对 Service Mesh 无甚了解，便意兴阑珊掩鼻而过。</p>

<p>话说缘分天注定。半载过后，愚人工作内容便是参与此项目相关系统开发，便需要对其机理深入了解，以免踩坑。</p>

<h2 id="toc_1">1 SOFAMosn</h2>

<p>SOFAMosn 是蚂蚁金服 Service Mesh 整体实践中最基础的组件。</p>

<p>参考文档 <a href="(github.com/apache/dubbo)">蚂蚁金服 Service Mesh 落地实践与挑战</a> 文中述及了蚂蚁金服当前的 Service Mesh 进展情况，不同于开源的 Istio 体系，蚂蚁金服内部版 Service Mesh 落地优先考虑数据面的实现与落地，控制面在逐步建设中，整体的架构上看，我们使用数据面直接和内部的各种中间件服务端对接，来完成 RPC、消息等能力的下沉，给业务应用减负。SOFAMosn 便是数据平面落地的产物。</p>

<p>SOFAMosn 在 Service Mesh 充当 sidecar 角色，可以粗浅地理解为 Go 语言版本的 Envoy，目前其形态如下：</p>

<p><img src="../pic/mosn/mosn_ant_arch.jpg" alt=""></p>

<p>整体架构与 RPC 有些许相似：</p>

<ul>
<li>通过 Registry 实现服务注册和服务通知</li>
<li>通过 ConfigServer 实现服务配置动态下发</li>
<li>相互之间通过 TCP/HTTP 进行 transport 通信</li>
<li>通过 MQ 进行 pub/sub；</li>
</ul>

<h2 id="toc_2">2 SOFAMosn 的基本概念</h2>

<p>愚人刚开始学习 SOFAMosn 相关概念的时候，是通过其配置文件，并类比于 Envoy 入门的。</p>

<p><img src="../pic/mosn/envoy_arch.jpg" alt=""></p>

<p>上图是 Service Mesh 布道师 宋净超(Jimmy Song) 绘制的 Envoy 架构图，用宋老师的一句话总结图中流程即为，host A 经过 Envoy 访问 host B 的过程，每个 host 上都可能运行多个 service，Envoy 中也可能有多个 Listener，每个 Listener 中可能会有多个 filter 组成了 chain。</p>

<h3 id="toc_3"><a name="2.1">2.1 SOFAMosn 配置</a></h3>

<p>SOFAMosn 的配置文件大体内容如下：</p>

<div><pre><code class="language-text/json">{&quot;servers&quot;: [
    {&quot;mosn_server_name&quot;: &quot;mosn_server_1&quot;,
      &quot;listeners&quot;: [{
          &quot;name&quot;: &quot;ingress_sofa&quot;,&quot;address&quot;: &quot;0.0.0.0:12220&quot;, &quot;type&quot;: &quot;ingress&quot;,
          &quot;filter_chains&quot;: [{
              &quot;match&quot;: &quot;&quot;,
              &quot;filters&quot;: [{
                  &quot;type&quot;: &quot;proxy&quot;,
                  &quot;config&quot;: {
                    &quot;downstream_protocol&quot;: &quot;SofaRpc&quot;,&quot;name&quot;: &quot;proxy_config&quot;,&quot;upstream_protocol&quot;: &quot;SofaRpc&quot;,&quot;router_config_name&quot;: &quot;test_router&quot;}},
                    {&quot;type&quot;: &quot;connection_manager&quot;,
                        &quot;config&quot;: {
                            &quot;virtual_hosts&quot;:[&quot;routers&quot;: [{&quot;route&quot;: {&quot;cluster_name&quot;: &quot;test_cpp&quot;}]]
                    }]}]}],
  &quot;cluster_manager&quot;: {
    &quot;clusters&quot;: [{
        &quot;name&quot;: &quot;test_cpp&quot;, &quot;lb_type&quot;: &quot;LB_ROUNDROBIN&quot;,
        &quot;health_check&quot;: {
          &quot;protocol&quot;: &quot;SofaRpc&quot;, &quot;timeout&quot;: &quot;90s&quot;},
        &quot;hosts&quot;: [{
            &quot;address&quot;: &quot;11.166.22.163:12200&quot;, &quot;hostname&quot;: &quot;downstream_machine1&quot;, &quot;weight&quot;: 1}]}]}
}</code></pre></div>

<p>上面内容源自开源版本 SOFAMosn 的配置文件 <a href="(https://github.com/sofastack/sofa-mosn/blob/master/configs/mosn_config.json)">mosn_config.json</a>，经愚人裁剪和合并，以利于阅读。</p>

<p>配置分为 &quot;servers&quot; 和 &quot;cluster_manager&quot; 两块。&quot;servers&quot; 主要存储了 SOFAMosn 对 &quot;host A&quot; 的监听端口。</p>

<p>&quot;cluster_manager&quot; 则用于描述其后端 upstream 提供 service 的 hosts 集合。</p>

<p>&quot;servers&quot; 和 &quot;cluster<em>manager&quot; 衔接的关键之处是 &quot;servers.listeners.filter</em>chains.filters.config.virtual<em>hosts.routers.route.cluster</em>name&quot;。</p>

<p>SOFAMosn 本质是一个 Local(Client-Side) Proxy，downstream 通过它把请求路由到 upstream。</p>

<h4 id="toc_4">2.1.1 SOFAMosn Servers</h4>

<p>套用宋老师的话，SOFAMosn 有多个 Listener 组成了 &quot;listeners&quot; ，每个 Listener 中有多个 Filters 组成了 &quot;filter_chains&quot;。</p>

<blockquote>
<p>Listener 是处于 downstream 位置的 “host A&quot; 可以访问的网络地址，一般为一个 tcp port。</p>

<p>Listener filter   可以理解为 codec（协议处理），每个port（listener）上可以有多个 filter，即在一个网络地址上可以进行多种downstream 协议解析。Listener 使用 listener filter（监听器过滤器）来操作链接的元数据。</p>
</blockquote>

<p>一般地，出于效率考虑，listen filter 不会完整解析 downstream 发来的完整协议，而是只解析部分头部，获取必要的路由相关的字段即可。</p>

<p>配置文件中 &quot;servers.listeners.filter_chains.filters.type&quot; 字段的值 &quot;proxy&quot; 完美地点出了 SOFAMosn 的 Local Prxoy 角色。</p>

<p>配置文件中的 &quot;servers.listeners.filter_chains.filters.config&quot; 中的 &quot;downstream&quot; 与 &quot;upstream&quot; 表明了其上下游使用的 filter(codec) 协议。</p>

<blockquote>
<p>Router 作为就是路由，用于选择 downstream 请求目的地 upstream cluster，是 MOSN 的核心模块，支持的功能包括：</p>
</blockquote>

<ul>
<li>VirtualHost 形式的路由功能</li>
<li>基于 subset 的子集群路由匹配</li>
<li>路由重试以及重定向功能</li>
</ul>

<p>配置文件中的 Router 是一种 VirtualHost 形式的路由，字段 &quot;servers.listeners.filter<em>chains.filters.config.virtual</em>hosts.routers.route.cluster<em>name&quot; 的值 &quot;test</em>cpp&quot;，表明其使用 ”cluster<em>manager.clusters.name“:&quot;test</em>cpp&quot; 的相关 cluster。</p>

<h4 id="toc_5">2.1.2 SOFAMosn cluster manager</h4>

<p>集群（cluster）是一组提供相同服务的 上游(upstream) 主机(Host) 集合，类比于 dubbo 中的 provider 列表，其内容主要有：</p>

<ul>
<li>负载均衡策略</li>
<li>健康检查</li>
<li>静态 upstream hosts 集合</li>
</ul>

<p>upstream cluster 集合除了可在配置中获取外，也可以通过 XDS 方式发现上游服务，其流程如下图：</p>

<p><img src="../pic/mosn/mosn_xprotocol.jpg" alt=""></p>

<p>图片流程清晰如斯，愚人就不再多用文字画蛇添足了。</p>

<h2 id="toc_6">3 SOFAMosn 网络层</h2>

<p>一般的 RPC，downstream 与 upstream 之间直接进行网络通信，其网络层模型如下：</p>

<p><img src="../pic/mosn/getty_3_layer.jpg" alt=""></p>

<p>上图中 RPC 各个模型的作用有文字解释，此处不再赘述。本质为 Proxy 的 SOFAMosn 隔离了 downstream 和 upstream，其网络模型如下：</p>

<p><img src="../pic/mosn/mosn_4_layers.jpg" alt=""></p>

<p>各个模块作用如下：</p>

<ul>
<li>NET/IO 对应 RPC 的 Streaming，用于读写底层的字节流，并检测连接；</li>
<li>Protocol 对应 RPC 的 Codec，用于编解码 Package；</li>
<li>Stream 用于封装请求和响应；</li>
<li>Proxy 用于在 downstream 和 upstream 之间进行 stream 转发；</li>
</ul>

<p>NET/IO 在代码层映射为 Listener 和 Connection，Listener 用来监听端口，并接收新连接。Connection 用来管理 Listener 上 accept 来的 tcp 连接，包括从 tcp conn 上读写数据等，接口定义在 <code>sofamosn/pkg/types/network.go</code>。</p>

<p>Protocol 收到 downstream 发来的二进制流后，根据配置文件中的协议名称选择相应的 decoder，解码后的报文整体包分为 header、body 和 tailer 三部分，接口定义在 <code>sofamosn/pkg/types/protocol.go</code>。</p>

<p>SOFAMosn 的 Stream 概念非常类似网络编程的 multiplexing 概念：通过全局唯一的 stream id 实现 request 和 response 报文关联，实现在一个连接上实现多路流传输。Stream 具有方向性，区分 upStream 和 downStream，且与协议强相关，不同格式的协议使用不同的 Stream。</p>

<p>Proxy 则是 SOFAMosn 角色的体现，在 upStream 和 downStream 之间进行路由选择，在 SOFAMosn 中其还管理连接池、service 集群。</p>

<h3 id="toc_7"><a name="3.1">3.1 网络线程模型</a></h3>

<p>SOFAMosn 网络层采用了两种网络模型，分别针对不同的使用场景。</p>

<p><img src="../pic/mosn/mosn_io_thread1.png" alt=""></p>

<p>上图是 SOFAMosn 0.1.0 版本的线程模型，也是一种比较经典的 Go 网络双工线程模型，其各个部分职能如下：</p>

<ul>
<li>读写分离，分别有两个 goroutine【下文简称 gr】处理网络阻塞读写；</li>
<li>读 gr 处理读 event，把二进制字节流转换为一个或多个报文；</li>
<li>写 gr 负责把 package 编码为二进制流，并发送出去；</li>
<li>一个专门的 event gr pool 负责逻辑处理。</li>
</ul>

<p>这种网络模型适合在连接数不满 1k 时处理吞吐比较高的长连接场景，但是在连接达 10k 的短链接场景就不合适了。最简单的道理，gr 数目达 20k 时 go 的 gr 调度器的调度处理效率极低。</p>

<p><img src="../pic/mosn/mosn_io_thread2.jpg" alt=""></p>

<p>上图则是 SOFAMosn 最新版本提供的第二种网络线程模型，基于 epoll/kqueue 机制重新实现的 NetPoll。SOFAMosn 根据 CPU 核数定制一个 Poller，每个 Poller 有一个常驻 gr，downstream connection 将自身注册的读写事件到某个 Poller 中，<u><strong>当 Poller 的 gr 接收到可读事件后，再从 gr pool 中选择一个 gr 执行网络读事件处理</strong></u>。</p>

<p>这种网络模型适用于短链接较多但是网络吞吐不高的场景，如 Gateway。</p>

<p>SOFAMosn 默认情况下适用第一种网络模型。</p>

<h2 id="toc_8">4 SOFAMosn 代码分析</h2>

<p>SOFAMosn 整体代码可读性不友好，估计其初始作者并没有很长时间的 Go 使用经验。</p>

<p>本节主要分析其配置解析、网络启动与网络事件处理流程，不涉及其运行流程。</p>

<h3 id="toc_9">4.1 Main 入口</h3>

<p>开源版本 SOFAMosn 的 Main 入口文件在 <a href="https://github.com/sofastack/sofa-mosn/blob/master/cmd/mosn/main/mosn.go">cmd/mosn/main/mosn.go</a>。</p>

<p>SOFAMosn 使用了第三方库封装了一个 APP 代表整体程序，并能够处理 start、stop 和 reload 三个控制命令，但在控制命令处理文件<a href="https://github.com/sofastack/sofa-mosn/blob/master/cmd/mosn/main/control.go">cmd/mosn/main/control.go</a> 中见到如下代码：</p>

<div><pre><code class="language-Go">    cmdStop = cli.Command{
        Name:  &quot;stop&quot;,
        Usage: &quot;stop mosn proxy&quot;,
        Action: func(c *cli.Context) error {
            return nil
        },
    }

    cmdReload = cli.Command{
        Name:  &quot;reload&quot;,
        Usage: &quot;reconfiguration&quot;,
        Action: func(c *cli.Context) error {
            return nil
        },
    }</code></pre></div>

<p>Stop 命令和 Reload 命令的 Action 函数为空，不知道这样的封装意义何在，涉嫌过度封装。实际使用命令仅仅 Start 而已。</p>

<p>整体 cmd/mosn/main 目录下有用的代码仅如下一行：</p>

<div><pre><code class="language-Go">    mosn.Start(conf, serviceCluster, serviceNode)</code></pre></div>

<p>如果还有其他有用代码的话，可能就是 <a href="https://github.com/sofastack/sofa-mosn/blob/master/cmd/mosn/main/mosn.go">mosn.go</a> 文件的 import 语句库，可让各个相关子目录的 init() 函数在 SOFAMosn 启动时被调用。</p>

<p>真正的 SOFAMosn 对象为文件 <a href="https://github.com/sofastack/sofa-mosn/blob/master/pkg/mosn/starter.go">mosn/starter.go</a> 中的 mosn.Mosn，其定义如下：</p>

<div><pre><code class="language-Go">// Mosn class which wrapper server
type Mosn struct {
    servers        []server.Server
    clustermanager types.ClusterManager
    routerManager  types.RouterManager
    config         *config.MOSNConfig
    adminServer    admin.Server
}</code></pre></div>

<p>Mosn 总体启动过程如下：</p>

<p><img src="../pic/mosn/mosn_start.png" alt=""></p>

<h3 id="toc_10">4.2 读取并分析配置文件</h3>

<p>前面 <a name="#2.1">2.1 SOFAMosn 配置</a> 一节中给出了 SOFAMosn 的标准配置文件，其对应的代码在 <a href="https://github.com/sofastack/sofa-mosn/blob/master/pkg/config/config.go">config/config.go</a>，主要结构体定义如下：</p>

<div><pre><code class="language-Go">type ApplicationInfo struct {
    AppName       string `json:&quot;app_name,omitempty&quot;`
}

// ServiceRegistryInfo
type ServiceRegistryInfo struct {
    ServiceAppInfo ApplicationInfo     `json:&quot;application,omitempty&quot;`
    MsgMetaInfo    map[string][]string `json:&quot;msg_meta_info,omitempty&quot;`
}

// MOSNConfig make up mosn to start the mosn project
// Servers contains the listener, filter and so on
// ClusterManager used to manage the upstream
type MOSNConfig struct {
    Servers         []v2.ServerConfig      `json:&quot;servers,omitempty&quot;`         //server config, listener
    ClusterManager  ClusterManagerConfig   `json:&quot;cluster_manager,omitempty&quot;` //cluster config, cluster
    ServiceRegistry v2.ServiceRegistryInfo `json:&quot;service_registry&quot;`          //service registry config, used by service discovery module
}</code></pre></div>

<p>配置整体解析流程如下：</p>

<p><img src="../pic/mosn/load_config.png" alt=""></p>

<p>NewMosn 函数中启动了一个 <code>config.DumpConfigHandler</code> 的 goroutine，定时把程序对配置的变更内容更新入配置文件中。</p>

<h3 id="toc_11">4.3 listener 启动流程</h3>

<p>SOFAMosn 的 servers 相关对象【server 和 listener】主要定义在 pkg/server 目录下，其主要文件内容如下：</p>

<ul>
<li><a href="https://github.com/sofastack/sofa-mosn/blob/master/pkg/server/types.go">types.go</a> 定义了一个 Server 接口</li>
<li><a href="https://github.com/sofastack/sofa-mosn/blob/master/pkg/server/server.go">server.go</a> 定义了接口 Server 的实现 sever struct</li>
<li><a href="https://github.com/sofastack/sofa-mosn/blob/master/pkg/server/handler.go">handler.go</a> 则定义了对 listener 各种事件的处理</li>
</ul>

<p>pkg/network 目录则定义了网络连接、监听与读写处理流程。</p>

<p>listener 启动流程如下：</p>

<ul>
<li>1 构建 server.activeListener 对象</li>
</ul>

<p><img src="../pic/mosn/build_listener.png" alt=""></p>

<ul>
<li>2 所有的 listener 对象构建完毕后，listener:Start() 开始监听各自的端口</li>
</ul>

<p><img src="../pic/mosn/listener_start.png" alt=""></p>

<ul>
<li>3 处理监听事件 server.activeListener.OnAccpet，创建 network/connection.go:connection 对象，调用 connection:Start() 启动 EventLoop</li>
</ul>

<h3 id="toc_12">4.4 网络读写事件处理</h3>

<p><a name="#3.1">3.1 网络线程模型</a> 节中述到 SOFAMosn 提供了两种网络线程模型，本节只给出其第一种网络线程模型【下文简称 orow】下的读写事件处理流程。</p>

<ul>
<li>1 启动监听事件</li>
</ul>

<p><img src="../pic/mosn/listener_listen.png" alt=""></p>

<ul>
<li>2 接收连接后的 FilterManager 对象初始化</li>
</ul>

<p><img src="../pic/mosn/new_filter_manager.png" alt=""></p>

<ul>
<li>3 orow 模型下的 transport 层的读流程</li>
</ul>

<p><img src="../pic/mosn/listener_read.png" alt=""></p>

<ul>
<li>4 orow 模型下的 transport 层的写流程</li>
</ul>

<p><img src="../pic/mosn/listener_write.png" alt=""></p>

<p>关于写，SOFAMosn 对写采用了合并写优化。<a href="(https://blog.csdn.net/sofastack/article/details/93558620)">蚂蚁金服 Service Mesh 落地实践与挑战</a> 一文写道，
通过 golang 的 writev 我们把多笔请求合并成一次写，降低 sys.call 的调用，提升整体的性能与吞吐，同时在使用 writev 的过程中，有发现 golang 对 writev 的实现有 bug，会导致部分内存无法回收，我们给 golang 提交 PR 修复此问题，已被接受：https://github.com/golang/go/pull/32138。</p>

<p>这个 bug 是同事元总【原 tengine 总负责人】发现并解决掉的，但是最新的 Go 语言尚未发版【Go 1.13】，实际处理方法则是把多次写的内容先在内存中合并，然后再调用一次写 sys.call 发送，相关代码如下：</p>

<div><pre><code class="language-Go">    // connection.startRWLoop()
    for i := 0; i &lt; 10; i++ {
        select {
        case buf, ok := &lt;-c.writeBufferChan:
            if !ok {
                return
            }
            c.appendBuffer(buf)
        default:
        }
    }</code></pre></div>

<h2 id="toc_13">参考文档</h2>

<ul>
<li>1 <a href="https://www.servicemesher.com/blog/sofa-mosn-deep-dive/">Service Mesh数据平面SOFAMosn深层揭秘</a></li>
<li>2 <a href="https://blog.csdn.net/sofastack/article/details/93558620">蚂蚁金服 Service Mesh 落地实践与挑战</a></li>
<li>3 <a href="http://alexstocks.github.io/html/service_mesh.html">Service Mesh 形态刍议</a></li>
<li>4 <a href="https://jimmysong.io/posts/envoy-archiecture-and-terminology/">Envoy 的架构与基本术语</a></li>
</ul>

<h2 id="toc_14">Payment</h2>

<div>
<table>
  <tbody>
  <tr></tr>
    <tr>
      <td align="center"  valign="middle">
        <a href="" target="_blank">
          <img width="100px"  src="../pic/pay/wepay.jpg">
        </a>
      </td>
      <td align="center"  valign="middle">
        <a href="" target="_blank">
          <img width="100px"  src="../pic/pay/alipay.jpg">
        </a>
   </tbody>
</table>
</div>

<h2 id="toc_15">Timeline</h2>

<blockquote>
<ul>
<li>2019/07/06，于雨氏，于西湖黄龙，初作此文。</li>
</ul>
</blockquote>


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!-- baidu statistic start -->
<script>
var _hmt = _hmt || [];
(function() {
	  var hm = document.createElement("script");
	    hm.src = "https://hm.baidu.com/hm.js?170a8df8802fbc47c7acc272d270979c";
		  var s = document.getElementsByTagName("script")[0];
		    s.parentNode.insertBefore(hm, s);
})();
</script>
<!-- baidu statistic end -->

<!-- Gitalk start -->
<link rel="stylesheet" href="https://unpkg.com/gitalk@latest/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
var gitalk = new Gitalk({
	clientID: '6211d8b94a8106bed6b0',
	clientSecret: 'bf77ca26c237eabbd45169e01bf03a5e96a1b26f',
	repo: 'alexstocks.github.io',
	owner: 'AlexStocks',
	admin: ['AlexStocks'],
	id: window.location.pathname,
	distractionFreeMode: true
});
gitalk.render('gitalk-container');
</script>
<!-- Gitalk end -->



</body>

</html>
