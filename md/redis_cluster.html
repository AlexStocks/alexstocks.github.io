<!DOCTYPE html>
<html>
<head>
<title>redis_cluster</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>一种基于Redis的多租户多粒度分布式内存文件系统设计</h2>
<hr />
<p><em>written by Alex Stocks on 2016/03/05</em></p>
<h3>1 前言</h3>
<hr />
<p>Redis是目前一种比较流行的内存数据库，但是其缺点也非常明显：</p>
<ul>
<li>
<p>1 Scale out能力</p>
<p>Redis采用了单进程架构，无法利用服务端多核的高性能，进而制约了其对服务器超大内存的使用能力。Redis能够使用的内存极限容量经验值为【8G, 24G】，超过这个容量上限其性能便急剧下降。</p>
</li>
<li>
<p>2 Scale up能力</p>
<p>基于Redis的cluster目前采用了两种设计模式：proxy based和无中心的smart client based(如官方的Redis 3.0)。官方实现的Redis Cluster把系统设计成了一个&quot;All-In-Box&quot;模式的cluster，看似简洁易用轻便很多，其实不过是多个模块应该执行的任务混合在一起让一个Redis执行了，看似平等的一模一样的Redis进程的逻辑变得很复杂起来，一旦出问题就是一堆乱麻，你就只能呵呵哒了。目前业界暂时没有关于Redis 3.0的比较成功的使用案例。</p>
<p>Proxy-based Redis Cluster看似让架构复杂很多，但是这种架构很容易做到让每个模块自身职责明了清晰，分工明确，每个模块可以独立部署升级，所以运维也就方便很多，契合微服务的精神。目前比较成功的proxy有twemproxy，比较方便使用的Redis Cluster有Codis等。</p>
</li>
</ul>
<h3>2 多租户与多粒度和内存分布式文件系统</h3>
<hr />
<p>目前各种Iaas层的云架构方兴未艾，OpenStack是目前最成功的架构中的一个，其特点之一便是能够构建一个提供多租户使用的公有云系统。不管是否基于公有云系统，如果想要构建一个多租户的Paas层的多租户的内存文件系统服务，囿于个人孤陋寡闻，目前还未见到比较成熟的相关系统。</p>
<p>磁盘文件系统最基本的的组织单元之一如扇区，其size一般固定为512B，基于扇区就可以构建4kB或者8kB等size的磁盘簇等多粒度存储单元，如果要构建一个内存文件系统，也可以基于类似的方式构建一个多粒度的内存文件系统。</p>
<p>Redis自身具有db的概念，即一个redis instance可以从逻辑上划分多个db分别给不同的用户使用，每个用户的数据从逻辑层面来看是相互隔离的，但是其缺点之一就是Redis不提供每个db占用的内存空间的size，更不能限制其内存使用量，用户一般能做的就是限制Redis instance自身占用的内存总量。</p>
<h3>3 关于数据一致性</h3>
<hr />
<p>Redis还有一个优点，可以通过master与slave构成一对Redis instance保证数据的consistency。但是这种一致性是一种最终一致性，并不能算是强一致性，即master处理一个写请求后，写请求的数据何时会被同步给slave且能让slave落盘成功，用户无法知晓。</p>
<p>一般的分布式文件系统可以基于data version来解决强一致性问题，但是Redis自身并不提供这种能力。在一个proxy based的系统中，proxy一般只承担数据请求的转发能力，为了保证用户写请求的强一致，可以进一步提高proxy的能力：区分读写请求和读写分离能力。</p>
<p>假设有一个简单的proxy based的系统如下所示：</p>
<p><img src="../pic/redis-instance.jpg" /></p>
<p>Proxy通过区分读写请求和读从写主的能力，如果要保证数据的强一致性，一个client的写流程如下：</p>
<ul>
<li>1 client发出Write Request；</li>
<li>2 proxy把Write Request转发给Rm；</li>
<li>3 Rm把Write Response结果返回给Proxy；</li>
<li>4 client收到Proxy转发回来的Write Response，如果失败就退出流程；</li>
<li>5 client再发出对同一个key的Read Request；</li>
<li>6 Proxy把Read Request转发给Rs；</li>
<li>7 Rs把value返回给Proxy；</li>
<li>8 Proxy把value返回给client；</li>
<li>9 client收到value。</li>
</ul>
<p>如果client读到的value与写入的value一致，便可以认为写成功了，否则认为是失败的，不管其原因是Rm与Rs的同步太慢还是中间整个流程耗时过长导致了请求超时。如果某个Redis的写操作被认为是幂等的，则用户可以通过重试上面的流程来提高写成功率。这个方案需要redis和proxy配合一起保证数据的强一致性。</p>
<p>还有一种选择。proxy可以向Rm发送info命令，可以得到其sync buffer的offset值master<em>repl</em>offset，依据写请求前后两个不同的offset值，大致地可以把上面的流程修改为：</p>
<ul>
<li>1 client发出Write Request；</li>
<li>2 proxy区分出请求是写请求，向Rm发出info命令；</li>
<li>3 待info命令超时之前如果Rm返回Info Response，proxy可以记录下此时的master<em>repl</em>offset值；</li>
<li>4 Proxy把Write Request转发给Rm；</li>
<li>5 Rm把Write Response结果返回给Proxy，如果结果是写失败，Proxy就把结果返回给client并退出流程，否则再次向Rm发出info命令；</li>
<li>6 Proxy收到Rm返回的Info Response，计算此时的master<em>repl</em>offset值，如果与此前的offset值不等，则Proxy就把Write Response结果返回给client，退出流程；</li>
<li>7 proxy sleep一段时间，再次发出info命令并等待结果，然后比较offset值，如果仍然相等则返回write fail，否则返回Rm的Write Response。</li>
</ul>
<p>以上两种方法各有优劣，分别适用不同的场景，用户自己取舍。如果是面向用户的服务，则采用方案一，proxy的任务轻便一些，如果是Redis Cluster内部的Redis另有它用（下面讲到的架构），则可以使用方案二。</p>
<p>另外，为了加快主从同步速度，建议关闭Rm的磁盘写能力，只让Rs开启磁盘存储能力。</p>
<h3>4 Redis Cluster架构</h3>
<hr />
<p>基于前面的分析，我手绘了一个Redis Cluster架构图如下：</p>
<p><img src="../pic/redis-cluster.jpg" /></p>
<p>为了综述方便，我不再详细解释cluster内部的详细流程，只分别介绍各个model的职责。</p>
<h4>4.1 Redis Proxy</h4>
<hr />
<p>Proxy处于cluster的代理层，其职责是：</p>
<ul>
<li>A 对Redis Pool内部的所有的Redis Instance进行全连接；</li>
<li>B 从meta master处获取Redis Pool内所有的Instance的host信息以及其内存粒度(quota)等信息；</li>
<li>C 从meta master处获取所有的database的信息；</li>
<li>D 从meta master处得到所有的user信息；</li>
<li>E 提供读写分离的能力；</li>
<li>F 定时地向master汇报心跳包，心跳包中可以包含诸如连接数、写请求数目、读请求数目、最新有数据更新的db等信息；</li>
<li>G 对master发来的各种命令做出响应；</li>
<li>H 监听master发来的如下消息：</li>
</ul>
<blockquote>
<p>1 资源池子中某个redis Instance对的主从切换消息；</p>
<p>2 发生主从后的新的Rs消息；</p>
<p>3 新注册的用户以及其使用的资源消息；</p>
<p>4 用户资源更改消息；</p>
<p>5 用户被删除消息；</p>
<p>6 用户使用的资源超出其粒度(quota)的消息；</p>
<p>7 封禁某个db响应写请求的消息；</p>
</blockquote>
<h4>4.2 Keeper</h4>
<hr />
<p>Keeper作为master的管家，具有管理Redis Pool的能力，其职责列表如下:</p>
<ul>
<li>A 从master处接收监控Redis Pool中某对Rm-Rs的命令；</li>
<li>B 从master处接收计算某个instance上某个db的占用内存大小的指令[简单地，可以读取Rs的磁盘文件来进行估算]；</li>
<li>C 从master处接收migrate指令以及源db和目标db两个参数；</li>
<li>D 某instance上Rm down掉是及时进行failover，并把心的Rm及时汇报给master；</li>
<li>E 从master处接收某个Rm新的Rs的命令，并向这个Rs发出slaveof指令；</li>
<li>F 把各个命令操作结果汇报master；</li>
<li>G 向master汇报心跳；</li>
</ul>
<h4>4.3 Meta Db</h4>
<hr />
<p>metadb作为meta信息的存储者，其能力列表如下:</p>
<ul>
<li>A 存储所有user的信息以及其使用的db信息列表；</li>
<li>B 存储Redis Pool之中所有的instance的host信息；</li>
<li>C 存储Redis Pool中所有db的size、owner user、quota、free state、create time和当前size等信息；</li>
<li>D 存储多粒度空闲db列表；</li>
<li>E 存储Redundant Redis Pool中所有instance以及db的信息；</li>
<li>F 提供一个的消息通道能力，以让master和proxy以及keeper之间进行通信。</li>
</ul>
<h4>4.4 Master</h4>
<hr />
<p>master作为整个cluster内的管理者，其职责列表如下：</p>
<ul>
<li>A 管理从32M、64M、128M、256M、512M和1G等各个粒度的instance pool；</li>
<li>B 接受用户创建以及其资源申请的请求；</li>
<li>C 统计各个proxy负载，以及选择一个负载最轻的proxy服务于user的请求；</li>
<li>D 接收超级管理员向资源池子(Redis Pool)或者备用资源管理池(Redundant REdis Pool)中添加新的Redis Instance以及其内存粒度大小和各个db编号等参数的命令；</li>
<li>E 接收keeper发来的Rm-Rs instance发生failover的消息通知，把新的Rm通知给各个proxy，从备用资源池中选出新的Rs'，通知给keeper，待keeper操作成功后更新metadb，并及时通知各个proxy；</li>
<li>F 接收proxy和keeper发来的心跳包；</li>
<li>G 根据proxy心跳包，发出统计某个db的内存size的指令给keeper；</li>
<li>H 如果某个db的size超出其粒度限额(quota)，则通知各个proxy封禁其写请求访问；</li>
<li>I 定时检测超出quota的db，一旦其db容量下降到合适额度，就通知proxy开放对其进行写请求的访问；</li>
<li>J 接收用户扩展其某个db的size指令，检验请求合法性并通过后，做出如下流程：</li>
</ul>
<blockquote>
<p>1 向各个proxy发出对某个db的写请求访问封禁通知；</p>
<p>2 收到所有的proxy响应后，从备用资源池抽出合适粒度的instance上的db，作为migrate命令的参数发给keeper；</p>
<p>3 根据keeper操作结果，修改metadb中db的相关信息；</p>
<p>4 命令keeper对原db做出drop操作；</p>
<p>5 通知各个proxy修改redis pool架构信息并开放对某个db的写请求访问；</p>
<p>6 返回成功或者失败信息给user。</p>
</blockquote>
<ul>
<li>K 接收用户缩减其某个db的size或者drop某个db的指令。</li>
</ul>
<h3>5 进一步的工作</h3>
<hr />
<p>上面的流程设计是假设Redis被部署于物理机之上，如果想要把Redis Instance部署在公有云系统之上呢？</p>
<h4>5.1 Redundant Redis Pool</h4>
<hr />
<p>上面的架构图设计是假设Redis被部署于物理机之上，所以附带了一个Redundant Redis Pool以应对Redis Instance failover的情况。如果整个系统能部署于openstack云系统之上，或者至少能否把Redis部署于docker集群之中，这个Redundant Redis Pool就完全没有存在的必要了。</p>
<p>因为docker容器启动速度是如此之快，所以还要未尝一个备用池子就没有必要了。当出现failover的情况的时候，master向云系统的管理者nova或者其职责相当的角色发送启动命令以及相关的参数，待容器启动成功之后就把它交个keeper就可以了，其他流程不用修改。</p>
<h4>5.2 master与proxy和keeper之间的通信</h4>
<hr />
<p>有没有想过，master可能是系统的单点？更别提keeper了。一种处理方法就是更改频繁的系统状态数据放在metadb之中，让master做到无状态，只是执行相关的逻辑任务而已，这样就解放了master和keeper，就算是他们崩溃掉也无谓了，重启即可，至于在同一个机器或者不同的机器重启都无所谓，至少保证用keepalived或者dns系统保证其地址不变即可。而且他们的任务并不繁重，所以更不必担心其通信数据量多少的问题。</p>
<p>那么，metadb究竟使用何种db合适呢？使用Mysql抑或是MongoDB或者是其他更高大上的系统？其实metadb存储的数据量不多，而且当系统出现不稳定情况的时候，就得快速响应master的数据请求，而且系统的状态这种更新频繁的数据也由它负责存储，metadb也用Redis充当即可。但是需要注意的是，master每次修改响应数据的时候，都要保证数据的强一致性，至于操作步骤可以参考第三章节。</p>
<p>上面的架构图以及相关的流程都讲到master需要和proxy以及keeper进行通信以完成相关系统任务以及Redis Instance状态的流转，但是他们之间究竟如何通信呢？最简单的情况，就是他们之间进行最基础的tcp通信。更进一步，metadb既然使用了Redis，是不是可以借用Redis的pub/sub能力？</p>
<p>至于metadb自身的稳定性，本文就不再赘述了。或者你有更好的方式处理之，总之是合适够用即可。</p>
<h2>扒粪者-于雨氏</h2>
<p>于雨氏，2016/03/05，于金箱堂。</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
